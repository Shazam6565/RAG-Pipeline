/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 2629:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stringWidth = __webpack_require__(5582)

function ansiAlign (text, opts) {
  if (!text) return text

  opts = opts || {}
  const align = opts.align || 'center'

  // short-circuit `align: 'left'` as no-op
  if (align === 'left') return text

  const split = opts.split || '\n'
  const pad = opts.pad || ' '
  const widthDiffFn = align !== 'right' ? halfDiff : fullDiff

  let returnString = false
  if (!Array.isArray(text)) {
    returnString = true
    text = String(text).split(split)
  }

  let width
  let maxWidth = 0
  text = text.map(function (str) {
    str = String(str)
    width = stringWidth(str)
    maxWidth = Math.max(width, maxWidth)
    return {
      str,
      width
    }
  }).map(function (obj) {
    return new Array(widthDiffFn(maxWidth, obj.width) + 1).join(pad) + obj.str
  })

  return returnString ? text.join(split) : text
}

ansiAlign.left = function left (text) {
  return ansiAlign(text, { align: 'left' })
}

ansiAlign.center = function center (text) {
  return ansiAlign(text, { align: 'center' })
}

ansiAlign.right = function right (text) {
  return ansiAlign(text, { align: 'right' })
}

module.exports = ansiAlign

function halfDiff (maxWidth, curWidth) {
  return Math.floor((maxWidth - curWidth) / 2)
}

function fullDiff (maxWidth, curWidth) {
  return maxWidth - curWidth
}


/***/ }),

/***/ 1371:
/***/ ((module) => {

"use strict";


module.exports = ({onlyFirst = false} = {}) => {
	const pattern = [
		'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
};


/***/ }),

/***/ 6462:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


const wrapAnsi16 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => (...args) => {
	const rgb = fn(...args);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

const ansi2ansi = n => n;
const rgb2rgb = (r, g, b) => [r, g, b];

const setLazyProperty = (object, property, get) => {
	Object.defineProperty(object, property, {
		get: () => {
			const value = get();

			Object.defineProperty(object, property, {
				value,
				enumerable: true,
				configurable: true
			});

			return value;
		},
		enumerable: true,
		configurable: true
	});
};

/** @type {typeof import('color-convert')} */
let colorConvert;
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
	if (colorConvert === undefined) {
		colorConvert = __webpack_require__(9047);
	}

	const offset = isBackground ? 10 : 0;
	const styles = {};

	for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
		const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
		if (sourceSpace === targetSpace) {
			styles[name] = wrap(identity, offset);
		} else if (typeof suite === 'object') {
			styles[name] = wrap(suite[targetSpace], offset);
		}
	}

	return styles;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],

			// Bright color
			blackBright: [90, 39],
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Alias bright black as gray (and grey)
	styles.color.gray = styles.color.blackBright;
	styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	styles.color.grey = styles.color.blackBright;
	styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
	setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});


/***/ }),

/***/ 9204:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const stringWidth = __webpack_require__(5582);
const chalk = __webpack_require__(8033);
const widestLine = __webpack_require__(7935);
const cliBoxes = __webpack_require__(7444);
const camelCase = __webpack_require__(894);
const ansiAlign = __webpack_require__(2629);
const wrapAnsi = __webpack_require__(7830);

const NL = '\n';
const PAD = ' ';

const terminalColumns = () => {
	const {env, stdout, stderr} = process;

	if (stdout && stdout.columns) {
		return stdout.columns;
	}

	if (stderr && stderr.columns) {
		return stderr.columns;
	}

	if (env.COLUMNS) {
		return Number.parseInt(env.COLUMNS, 10);
	}

	return 80;
};

const getObject = detail => {
	return typeof detail === 'number' ? {
		top: detail,
		right: detail * 3,
		bottom: detail,
		left: detail * 3
	} : {
		top: 0,
		right: 0,
		bottom: 0,
		left: 0,
		...detail
	};
};

const getBorderChars = borderStyle => {
	const sides = [
		'topLeft',
		'topRight',
		'bottomRight',
		'bottomLeft',
		'vertical',
		'horizontal'
	];

	let chararacters;

	if (typeof borderStyle === 'string') {
		chararacters = cliBoxes[borderStyle];

		if (!chararacters) {
			throw new TypeError(`Invalid border style: ${borderStyle}`);
		}
	} else {
		for (const side of sides) {
			if (!borderStyle[side] || typeof borderStyle[side] !== 'string') {
				throw new TypeError(`Invalid border style: ${side}`);
			}
		}

		chararacters = borderStyle;
	}

	return chararacters;
};

const makeTitle = (text, horizontal, alignement) => {
	let title = '';

	const textWidth = stringWidth(text);

	switch (alignement) {
		case 'left':
			title = text + horizontal.slice(textWidth);
			break;
		case 'right':
			title = horizontal.slice(textWidth) + text;
			break;
		default:
			horizontal = horizontal.slice(textWidth);

			if (horizontal.length % 2 === 1) { // This is needed in case the length is odd
				horizontal = horizontal.slice(Math.floor(horizontal.length / 2));
				title = horizontal.slice(1) + text + horizontal; // We reduce the left part of one character to avoid the bar to go beyond its limit
			} else {
				horizontal = horizontal.slice(horizontal.length / 2);
				title = horizontal + text + horizontal;
			}

			break;
	}

	return title;
};

const makeContentText = (text, padding, columns, align) => {
	text = ansiAlign(text, {align});
	let lines = text.split(NL);
	const textWidth = widestLine(text);

	const max = columns - padding.left - padding.right;

	if (textWidth > max) {
		const newLines = [];
		for (const line of lines) {
			const createdLines = wrapAnsi(line, max, {hard: true});
			const alignedLines = ansiAlign(createdLines, {align});
			const alignedLinesArray = alignedLines.split('\n');
			const longestLength = Math.max(...alignedLinesArray.map(s => stringWidth(s)));

			for (const alignedLine of alignedLinesArray) {
				let paddedLine;
				switch (align) {
					case 'center':
						paddedLine = PAD.repeat((max - longestLength) / 2) + alignedLine;
						break;
					case 'right':
						paddedLine = PAD.repeat(max - longestLength) + alignedLine;
						break;
					default:
						paddedLine = alignedLine;
						break;
				}

				newLines.push(paddedLine);
			}
		}

		lines = newLines;
	}

	if (align === 'center' && textWidth < max) {
		lines = lines.map(line => PAD.repeat((max - textWidth) / 2) + line);
	} else if (align === 'right' && textWidth < max) {
		lines = lines.map(line => PAD.repeat(max - textWidth) + line);
	}

	const paddingLeft = PAD.repeat(padding.left);
	const paddingRight = PAD.repeat(padding.right);

	lines = lines.map(line => paddingLeft + line + paddingRight);

	lines = lines.map(line => {
		if (columns - stringWidth(line) > 0) {
			switch (align) {
				case 'center':
					return line + PAD.repeat(columns - stringWidth(line));
				case 'right':
					return line + PAD.repeat(columns - stringWidth(line));
				default:
					return line + PAD.repeat(columns - stringWidth(line));
			}
		}

		return line;
	});

	if (padding.top > 0) {
		lines = new Array(padding.top).fill(PAD.repeat(columns)).concat(lines);
	}

	if (padding.bottom > 0) {
		lines = lines.concat(new Array(padding.bottom).fill(PAD.repeat(columns)));
	}

	return lines.join(NL);
};

const isHex = color => color.match(/^#(?:[0-f]{3}){1,2}$/i);
const isColorValid = color => typeof color === 'string' && ((chalk[color]) || isHex(color));
const getColorFn = color => isHex(color) ? chalk.hex(color) : chalk[color];
const getBGColorFn = color => isHex(color) ? chalk.bgHex(color) : chalk[camelCase(['bg', color])];

module.exports = (text, options) => {
	options = {
		padding: 0,
		borderStyle: 'single',
		dimBorder: false,
		textAlignment: 'left',
		float: 'left',
		titleAlignment: 'left',
		...options
	};

	// This option is deprecated
	if (options.align) {
		options.textAlignment = options.align;
	}

	const BORDERS_WIDTH = 2;

	if (options.borderColor && !isColorValid(options.borderColor)) {
		throw new Error(`${options.borderColor} is not a valid borderColor`);
	}

	if (options.backgroundColor && !isColorValid(options.backgroundColor)) {
		throw new Error(`${options.backgroundColor} is not a valid backgroundColor`);
	}

	const chars = getBorderChars(options.borderStyle);
	const padding = getObject(options.padding);
	const margin = getObject(options.margin);

	const colorizeBorder = border => {
		const newBorder = options.borderColor ? getColorFn(options.borderColor)(border) : border;
		return options.dimBorder ? chalk.dim(newBorder) : newBorder;
	};

	const colorizeContent = content => options.backgroundColor ? getBGColorFn(options.backgroundColor)(content) : content;

	const columns = terminalColumns() - 1;

	let contentWidth = widestLine(wrapAnsi(text, columns - BORDERS_WIDTH, {hard: true, trim: false})) + padding.left + padding.right;

	// This prevents the title bar to exceed the console's width
	let title = options.title && options.title.slice(0, columns - 4 - margin.left - margin.right);

	if (title) {
		title = ` ${title} `;
		// Make the box larger to fit a larger title
		if (stringWidth(title) > contentWidth) {
			contentWidth = stringWidth(title);
		}
	}

	if ((margin.left && margin.right) && contentWidth + BORDERS_WIDTH + margin.left + margin.right > columns) {
		// Let's assume we have margins: left = 3, right = 5, in total = 8
		const spaceForMargins = columns - contentWidth - BORDERS_WIDTH;
		// Let's assume we have space = 4
		const multiplier = spaceForMargins / (margin.left + margin.right);
		// Here: multiplier = 4/8 = 0.5
		margin.left = Math.max(0, Math.floor(margin.left * multiplier));
		margin.right = Math.max(0, Math.floor(margin.right * multiplier));
		// Left: 3 * 0.5 = 1.5 -> 1
		// Right: 6 * 0.5 = 3
	}

	// Prevent content from exceeding the console's width
	contentWidth = Math.min(contentWidth, columns - BORDERS_WIDTH - margin.left - margin.right);

	text = makeContentText(text, padding, contentWidth, options.textAlignment);

	let marginLeft = PAD.repeat(margin.left);

	if (options.float === 'center') {
		const marginWidth = Math.max((columns - contentWidth - BORDERS_WIDTH) / 2, 0);
		marginLeft = PAD.repeat(marginWidth);
	} else if (options.float === 'right') {
		const marginWidth = Math.max(columns - contentWidth - margin.right - BORDERS_WIDTH, 0);
		marginLeft = PAD.repeat(marginWidth);
	}

	const horizontal = chars.horizontal.repeat(contentWidth);
	const top = colorizeBorder(NL.repeat(margin.top) + marginLeft + chars.topLeft + (title ? makeTitle(title, horizontal, options.titleAlignment) : horizontal) + chars.topRight);
	const bottom = colorizeBorder(marginLeft + chars.bottomLeft + horizontal + chars.bottomRight + NL.repeat(margin.bottom));
	const side = colorizeBorder(chars.vertical);

	const LINE_SEPARATOR = NL;

	const lines = text.split(NL);

	const middle = lines.map(line => {
		return marginLeft + side + colorizeContent(line) + side;
	}).join(LINE_SEPARATOR);

	return top + LINE_SEPARATOR + middle + LINE_SEPARATOR + bottom;
};

module.exports._borderStyles = cliBoxes;


/***/ }),

/***/ 894:
/***/ ((module) => {

"use strict";


const UPPERCASE = /[\p{Lu}]/u;
const LOWERCASE = /[\p{Ll}]/u;
const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
const SEPARATORS = /[_.\- ]+/;

const LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);
const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');
const NUMBERS_AND_IDENTIFIER = new RegExp('\\d+' + IDENTIFIER.source, 'gu');

const preserveCamelCase = (string, toLowerCase, toUpperCase) => {
	let isLastCharLower = false;
	let isLastCharUpper = false;
	let isLastLastCharUpper = false;

	for (let i = 0; i < string.length; i++) {
		const character = string[i];

		if (isLastCharLower && UPPERCASE.test(character)) {
			string = string.slice(0, i) + '-' + string.slice(i);
			isLastCharLower = false;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = true;
			i++;
		} else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
			string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = false;
			isLastCharLower = true;
		} else {
			isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
		}
	}

	return string;
};

const preserveConsecutiveUppercase = (input, toLowerCase) => {
	LEADING_CAPITAL.lastIndex = 0;

	return input.replace(LEADING_CAPITAL, m1 => toLowerCase(m1));
};

const postProcess = (input, toUpperCase) => {
	SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
	NUMBERS_AND_IDENTIFIER.lastIndex = 0;

	return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier))
		.replace(NUMBERS_AND_IDENTIFIER, m => toUpperCase(m));
};

const camelCase = (input, options) => {
	if (!(typeof input === 'string' || Array.isArray(input))) {
		throw new TypeError('Expected the input to be `string | string[]`');
	}

	options = {
		pascalCase: false,
		preserveConsecutiveUppercase: false,
		...options
	};

	if (Array.isArray(input)) {
		input = input.map(x => x.trim())
			.filter(x => x.length)
			.join('-');
	} else {
		input = input.trim();
	}

	if (input.length === 0) {
		return '';
	}

	const toLowerCase = options.locale === false ?
		string => string.toLowerCase() :
		string => string.toLocaleLowerCase(options.locale);
	const toUpperCase = options.locale === false ?
		string => string.toUpperCase() :
		string => string.toLocaleUpperCase(options.locale);

	if (input.length === 1) {
		return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
	}

	const hasUpperCase = input !== toLowerCase(input);

	if (hasUpperCase) {
		input = preserveCamelCase(input, toLowerCase, toUpperCase);
	}

	input = input.replace(LEADING_SEPARATORS, '');

	if (options.preserveConsecutiveUppercase) {
		input = preserveConsecutiveUppercase(input, toLowerCase);
	} else {
		input = toLowerCase(input);
	}

	if (options.pascalCase) {
		input = toUpperCase(input.charAt(0)) + input.slice(1);
	}

	return postProcess(input, toUpperCase);
};

module.exports = camelCase;
// TODO: Remove this for the next major release
module.exports["default"] = camelCase;


/***/ }),

/***/ 7444:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const cliBoxes = __webpack_require__(4402);

module.exports = cliBoxes;
// TODO: Remove this for the next major release
module.exports["default"] = cliBoxes;


/***/ }),

/***/ 9246:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* MIT license */
/* eslint-disable no-mixed-operators */
const cssKeywords = __webpack_require__(6931);

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
	reverseKeywords[cssKeywords[key]] = key;
}

const convert = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

module.exports = convert;

// Hide .channels and .labels properties
for (const model of Object.keys(convert)) {
	if (!('channels' in convert[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert[model].labels.length !== convert[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert[model];
	delete convert[model].channels;
	delete convert[model].labels;
	Object.defineProperty(convert[model], 'channels', {value: channels});
	Object.defineProperty(convert[model], 'labels', {value: labels});
}

convert.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Infinity;
	let currentClosestKeyword;

	for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	let r = rgb[0] / 255;
	let g = rgb[1] / 255;
	let b = rgb[2] / 255;

	// Assume sRGB
	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	const xyz = convert.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t2;
	let t3;
	let val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces */
	switch (i) {
		default:
		case 6:
		case 0: r = v;  g = n;  b = wh; break;
		case 1: r = n;  g = v;  b = wh; break;
		case 2: r = wh; g = v;  b = n; break;
		case 3: r = wh; g = n;  b = v; break;
		case 4: r = n;  g = wh; b = v; break;
		case 5: r = v;  g = wh; b = n; break;
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces */

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// Assume sRGB
	r = r > 0.0031308
		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (~~(args > 50) + 1) * 0.5;
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(char => {
			return char + char;
		}).join('');
	}

	const integer = parseInt(colorString, 16);
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let grayscale;
	let hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

	let f = 0;
	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}
	/* eslint-enable max-statements-per-line */

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1.0 - c);
	let f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1.0 - c) + 0.5 * c;
	let s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hsv = convert.gray.hsl;

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (val << 16) + (val << 8) + val;

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),

/***/ 9047:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const conversions = __webpack_require__(9246);
const route = __webpack_require__(802);

const convert = {};

const models = Object.keys(conversions);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),

/***/ 802:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const conversions = __webpack_require__(9246);

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),

/***/ 6931:
/***/ ((module) => {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ 1354:
/***/ ((module) => {

"use strict";


module.exports = function () {
  // https://mths.be/emoji
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};


/***/ }),

/***/ 5325:
/***/ ((module) => {

"use strict";
var ne=Object.defineProperty;var ge=Object.getOwnPropertyDescriptor;var be=Object.getOwnPropertyNames;var Te=Object.prototype.hasOwnProperty;var Ae=(e,t)=>{for(var r in t)ne(e,r,{get:t[r],enumerable:!0})},Ie=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of be(t))!Te.call(e,i)&&i!==r&&ne(e,i,{get:()=>t[i],enumerable:!(n=ge(t,i))||n.enumerable});return e};var De=e=>Ie(ne({},"__esModule",{value:!0}),e);var Be={};Ae(Be,{Immer:()=>J,applyPatches:()=>Ce,castDraft:()=>ke,castImmutable:()=>Ke,createDraft:()=>Re,current:()=>re,enableMapSet:()=>xe,enablePatches:()=>Pe,finishDraft:()=>ve,freeze:()=>K,immerable:()=>N,isDraft:()=>O,isDraftable:()=>A,nothing:()=>z,original:()=>le,produce:()=>Fe,produceWithPatches:()=>Ne,setAutoFreeze:()=>je,setUseStrictShallowCopy:()=>ze});module.exports=De(Be);var z=Symbol.for("immer-nothing"),N=Symbol.for("immer-draftable"),f=Symbol.for("immer-state");function h(e,...t){throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)}var j=Object.getPrototypeOf;function O(e){return!!e&&!!e[f]}function A(e){return e?ye(e)||Array.isArray(e)||!!e[N]||!!e.constructor?.[N]||v(e)||k(e):!1}var Oe=Object.prototype.constructor.toString();function ye(e){if(!e||typeof e!="object")return!1;let t=j(e);if(t===null)return!0;let r=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return r===Object?!0:typeof r=="function"&&Function.toString.call(r)===Oe}function le(e){return O(e)||h(15,e),e[f].t}function M(e,t){C(e)===0?Reflect.ownKeys(e).forEach(r=>{t(r,e[r],e)}):e.forEach((r,n)=>t(n,r,e))}function C(e){let t=e[f];return t?t.o:Array.isArray(e)?1:v(e)?2:k(e)?3:0}function R(e,t){return C(e)===2?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function X(e,t){return C(e)===2?e.get(t):e[t]}function Q(e,t,r){let n=C(e);n===2?e.set(t,r):n===3?e.add(r):e[t]=r}function pe(e,t){return e===t?e!==0||1/e===1/t:e!==e&&t!==t}function v(e){return e instanceof Map}function k(e){return e instanceof Set}function T(e){return e.e||e.t}function L(e,t){if(v(e))return new Map(e);if(k(e))return new Set(e);if(Array.isArray(e))return Array.prototype.slice.call(e);if(!t&&ye(e))return j(e)?{...e}:Object.assign(Object.create(null),e);let r=Object.getOwnPropertyDescriptors(e);delete r[f];let n=Reflect.ownKeys(r);for(let i=0;i<n.length;i++){let c=n[i],y=r[c];y.writable===!1&&(y.writable=!0,y.configurable=!0),(y.get||y.set)&&(r[c]={configurable:!0,writable:!0,enumerable:y.enumerable,value:e[c]})}return Object.create(j(e),r)}function K(e,t=!1){return $(e)||O(e)||!A(e)||(C(e)>1&&(e.set=e.add=e.clear=e.delete=_e),Object.freeze(e),t&&Object.entries(e).forEach(([r,n])=>K(n,!0))),e}function _e(){h(2)}function $(e){return Object.isFrozen(e)}var ae={};function w(e){let t=ae[e];return t||h(0,e),t}function Y(e,t){ae[e]||(ae[e]=t)}var U;function B(){return U}function Me(e,t){return{a:[],i:e,p:t,P:!0,d:0}}function oe(e,t){t&&(w("Patches"),e.f=[],e.h=[],e.b=t)}function V(e){Z(e),e.a.forEach(we),e.a=null}function Z(e){e===U&&(U=e.i)}function ie(e){return U=Me(U,e)}function we(e){let t=e[f];t.o===0||t.o===1?t.x():t.m=!0}function se(e,t){t.d=t.a.length;let r=t.a[0];return e!==void 0&&e!==r?(r[f].s&&(V(t),h(4)),A(e)&&(e=ee(t,e),t.i||te(t,e)),t.f&&w("Patches").T(r[f].t,e,t.f,t.h)):e=ee(t,r,[]),V(t),t.f&&t.b(t.f,t.h),e!==z?e:void 0}function ee(e,t,r){if($(t))return t;let n=t[f];if(!n)return M(t,(i,c)=>de(e,n,t,i,c,r)),t;if(n.n!==e)return t;if(!n.s)return te(e,n.t,!0),n.t;if(!n.c){n.c=!0,n.n.d--;let i=n.e,c=i,y=!1;n.o===3&&(c=new Set(i),i.clear(),y=!0),M(c,(u,b)=>de(e,n,i,u,b,r,y)),te(e,i,!1),r&&e.f&&w("Patches").g(n,r,e.f,e.h)}return n.e}function de(e,t,r,n,i,c,y){if(O(i)){let u=c&&t&&t.o!==3&&!R(t.r,n)?c.concat(n):void 0,b=ee(e,i,u);if(Q(r,n,b),O(b))e.P=!1;else return}else y&&r.add(i);if(A(i)&&!$(i)){if(!e.p.y&&e.d<1)return;ee(e,i),(!t||!t.n.i)&&typeof n!="symbol"&&Object.prototype.propertyIsEnumerable.call(r,n)&&te(e,i)}}function te(e,t,r=!1){!e.i&&e.p.y&&e.P&&K(t,r)}function he(e,t){let r=Array.isArray(e),n={o:r?1:0,n:t?t.n:B(),s:!1,c:!1,r:{},i:t,t:e,u:null,e:null,x:null,l:!1},i=n,c=ue;r&&(i=[n],c=q);let{revoke:y,proxy:u}=Proxy.revocable(i,c);return n.u=u,n.x=y,u}var ue={get(e,t){if(t===f)return e;let r=T(e);if(!R(r,t))return Ee(e,r,t);let n=r[t];return e.c||!A(n)?n:n===ce(e.t,t)?(fe(e),e.e[t]=W(n,e)):n},has(e,t){return t in T(e)},ownKeys(e){return Reflect.ownKeys(T(e))},set(e,t,r){let n=me(T(e),t);if(n?.set)return n.set.call(e.u,r),!0;if(!e.s){let i=ce(T(e),t),c=i?.[f];if(c&&c.t===r)return e.e[t]=r,e.r[t]=!1,!0;if(pe(r,i)&&(r!==void 0||R(e.t,t)))return!0;fe(e),E(e)}return e.e[t]===r&&(r!==void 0||t in e.e)||Number.isNaN(r)&&Number.isNaN(e.e[t])||(e.e[t]=r,e.r[t]=!0),!0},deleteProperty(e,t){return ce(e.t,t)!==void 0||t in e.t?(e.r[t]=!1,fe(e),E(e)):delete e.r[t],e.e&&delete e.e[t],!0},getOwnPropertyDescriptor(e,t){let r=T(e),n=Reflect.getOwnPropertyDescriptor(r,t);return n&&{writable:!0,configurable:e.o!==1||t!=="length",enumerable:n.enumerable,value:r[t]}},defineProperty(){h(11)},getPrototypeOf(e){return j(e.t)},setPrototypeOf(){h(12)}},q={};M(ue,(e,t)=>{q[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}});q.deleteProperty=function(e,t){return q.set.call(this,e,t,void 0)};q.set=function(e,t,r){return ue.set.call(this,e[0],t,r,e[0])};function ce(e,t){let r=e[f];return(r?T(r):e)[t]}function Ee(e,t,r){let n=me(t,r);return n?"value"in n?n.value:n.get?.call(e.u):void 0}function me(e,t){if(!(t in e))return;let r=j(e);for(;r;){let n=Object.getOwnPropertyDescriptor(r,t);if(n)return n;r=j(r)}}function E(e){e.s||(e.s=!0,e.i&&E(e.i))}function fe(e){e.e||(e.e=L(e.t,e.n.p.S))}var J=class{constructor(t){this.y=!0;this.S=!1;this.produce=(t,r,n)=>{if(typeof t=="function"&&typeof r!="function"){let c=r;r=t;let y=this;return function(b=c,...a){return y.produce(b,o=>r.call(this,o,...a))}}typeof r!="function"&&h(6),n!==void 0&&typeof n!="function"&&h(7);let i;if(A(t)){let c=ie(this),y=W(t,void 0),u=!0;try{i=r(y),u=!1}finally{u?V(c):Z(c)}return oe(c,n),se(i,c)}else if(!t||typeof t!="object"){if(i=r(t),i===void 0&&(i=t),i===z&&(i=void 0),this.y&&K(i,!0),n){let c=[],y=[];w("Patches").T(t,i,c,y),n(c,y)}return i}else h(1,t)};this.produceWithPatches=(t,r)=>{if(typeof t=="function")return(y,...u)=>this.produceWithPatches(y,b=>t(b,...u));let n,i;return[this.produce(t,r,(y,u)=>{n=y,i=u}),n,i]};typeof t?.autoFreeze=="boolean"&&this.setAutoFreeze(t.autoFreeze),typeof t?.useStrictShallowCopy=="boolean"&&this.setUseStrictShallowCopy(t.useStrictShallowCopy)}createDraft(t){A(t)||h(8),O(t)&&(t=re(t));let r=ie(this),n=W(t,void 0);return n[f].l=!0,Z(r),n}finishDraft(t,r){let n=t&&t[f];(!n||!n.l)&&h(9);let{n:i}=n;return oe(i,r),se(void 0,i)}setAutoFreeze(t){this.y=t}setUseStrictShallowCopy(t){this.S=t}applyPatches(t,r){let n;for(n=r.length-1;n>=0;n--){let c=r[n];if(c.path.length===0&&c.op==="replace"){t=c.value;break}}n>-1&&(r=r.slice(n+1));let i=w("Patches").A;return O(t)?i(t,r):this.produce(t,c=>i(c,r))}};function W(e,t){let r=v(e)?w("MapSet").I(e,t):k(e)?w("MapSet").D(e,t):he(e,t);return(t?t.n:B()).a.push(r),r}function re(e){return O(e)||h(10,e),Se(e)}function Se(e){if(!A(e)||$(e))return e;let t=e[f],r;if(t){if(!t.s)return t.t;t.c=!0,r=L(e,t.n.p.S)}else r=L(e,!0);return M(r,(n,i)=>{Q(r,n,Se(i))}),t&&(t.c=!1),r}function Pe(){let t="replace",r="add",n="remove";function i(s,S,m,x){switch(s.o){case 0:case 2:return y(s,S,m,x);case 1:return c(s,S,m,x);case 3:return u(s,S,m,x)}}function c(s,S,m,x){let{t:I,r:P}=s,g=s.e;g.length<I.length&&([I,g]=[g,I],[m,x]=[x,m]);for(let l=0;l<I.length;l++)if(P[l]&&g[l]!==I[l]){let d=S.concat([l]);m.push({op:t,path:d,value:p(g[l])}),x.push({op:t,path:d,value:p(I[l])})}for(let l=I.length;l<g.length;l++){let d=S.concat([l]);m.push({op:r,path:d,value:p(g[l])})}for(let l=g.length-1;I.length<=l;--l){let d=S.concat([l]);x.push({op:n,path:d})}}function y(s,S,m,x){let{t:I,e:P}=s;M(s.r,(g,l)=>{let d=X(I,g),H=X(P,g),F=l?R(I,g)?t:r:n;if(d===H&&F===t)return;let D=S.concat(g);m.push(F===n?{op:F,path:D}:{op:F,path:D,value:H}),x.push(F===r?{op:n,path:D}:F===n?{op:r,path:D,value:p(d)}:{op:t,path:D,value:p(d)})})}function u(s,S,m,x){let{t:I,e:P}=s,g=0;I.forEach(l=>{if(!P.has(l)){let d=S.concat([g]);m.push({op:n,path:d,value:l}),x.unshift({op:r,path:d,value:l})}g++}),g=0,P.forEach(l=>{if(!I.has(l)){let d=S.concat([g]);m.push({op:r,path:d,value:l}),x.unshift({op:n,path:d,value:l})}g++})}function b(s,S,m,x){m.push({op:t,path:[],value:S===z?void 0:S}),x.push({op:t,path:[],value:s})}function a(s,S){return S.forEach(m=>{let{path:x,op:I}=m,P=s;for(let H=0;H<x.length-1;H++){let F=C(P),D=x[H];typeof D!="string"&&typeof D!="number"&&(D=""+D),(F===0||F===1)&&(D==="__proto__"||D==="constructor")&&h(16+3),typeof P=="function"&&D==="prototype"&&h(16+3),P=X(P,D),typeof P!="object"&&h(16+2,x.join("/"))}let g=C(P),l=o(m.value),d=x[x.length-1];switch(I){case t:switch(g){case 2:return P.set(d,l);case 3:h(16);default:return P[d]=l}case r:switch(g){case 1:return d==="-"?P.push(l):P.splice(d,0,l);case 2:return P.set(d,l);case 3:return P.add(l);default:return P[d]=l}case n:switch(g){case 1:return P.splice(d,1);case 2:return P.delete(d);case 3:return P.delete(m.value);default:return delete P[d]}default:h(16+1,I)}}),s}function o(s){if(!A(s))return s;if(Array.isArray(s))return s.map(o);if(v(s))return new Map(Array.from(s.entries()).map(([m,x])=>[m,o(x)]));if(k(s))return new Set(Array.from(s).map(o));let S=Object.create(j(s));for(let m in s)S[m]=o(s[m]);return R(s,N)&&(S[N]=s[N]),S}function p(s){return O(s)?o(s):s}Y("Patches",{A:a,g:i,T:b})}function xe(){class e extends Map{constructor(a,o){super();this[f]={o:2,i:o,n:o?o.n:B(),s:!1,c:!1,e:void 0,r:void 0,t:a,u:this,l:!1,m:!1}}get size(){return T(this[f]).size}has(a){return T(this[f]).has(a)}set(a,o){let p=this[f];return y(p),(!T(p).has(a)||T(p).get(a)!==o)&&(r(p),E(p),p.r.set(a,!0),p.e.set(a,o),p.r.set(a,!0)),this}delete(a){if(!this.has(a))return!1;let o=this[f];return y(o),r(o),E(o),o.t.has(a)?o.r.set(a,!1):o.r.delete(a),o.e.delete(a),!0}clear(){let a=this[f];y(a),T(a).size&&(r(a),E(a),a.r=new Map,M(a.t,o=>{a.r.set(o,!1)}),a.e.clear())}forEach(a,o){let p=this[f];T(p).forEach((s,S,m)=>{a.call(o,this.get(S),S,this)})}get(a){let o=this[f];y(o);let p=T(o).get(a);if(o.c||!A(p)||p!==o.t.get(a))return p;let s=W(p,o);return r(o),o.e.set(a,s),s}keys(){return T(this[f]).keys()}values(){let a=this.keys();return{[Symbol.iterator]:()=>this.values(),next:()=>{let o=a.next();return o.done?o:{done:!1,value:this.get(o.value)}}}}entries(){let a=this.keys();return{[Symbol.iterator]:()=>this.entries(),next:()=>{let o=a.next();if(o.done)return o;let p=this.get(o.value);return{done:!1,value:[o.value,p]}}}}[(f,Symbol.iterator)](){return this.entries()}}function t(u,b){return new e(u,b)}function r(u){u.e||(u.r=new Map,u.e=new Map(u.t))}class n extends Set{constructor(a,o){super();this[f]={o:3,i:o,n:o?o.n:B(),s:!1,c:!1,e:void 0,t:a,u:this,a:new Map,m:!1,l:!1}}get size(){return T(this[f]).size}has(a){let o=this[f];return y(o),o.e?!!(o.e.has(a)||o.a.has(a)&&o.e.has(o.a.get(a))):o.t.has(a)}add(a){let o=this[f];return y(o),this.has(a)||(c(o),E(o),o.e.add(a)),this}delete(a){if(!this.has(a))return!1;let o=this[f];return y(o),c(o),E(o),o.e.delete(a)||(o.a.has(a)?o.e.delete(o.a.get(a)):!1)}clear(){let a=this[f];y(a),T(a).size&&(c(a),E(a),a.e.clear())}values(){let a=this[f];return y(a),c(a),a.e.values()}entries(){let a=this[f];return y(a),c(a),a.e.entries()}keys(){return this.values()}[(f,Symbol.iterator)](){return this.values()}forEach(a,o){let p=this.values(),s=p.next();for(;!s.done;)a.call(o,s.value,s.value,this),s=p.next()}}function i(u,b){return new n(u,b)}function c(u){u.e||(u.e=new Set,u.t.forEach(b=>{if(A(b)){let a=W(b,u);u.a.set(b,a),u.e.add(a)}else u.e.add(b)}))}function y(u){u.m&&h(3,JSON.stringify(T(u)))}Y("MapSet",{I:t,D:i})}var _=new J,Fe=_.produce,Ne=_.produceWithPatches.bind(_),je=_.setAutoFreeze.bind(_),ze=_.setUseStrictShallowCopy.bind(_),Ce=_.applyPatches.bind(_),Re=_.createDraft.bind(_),ve=_.finishDraft.bind(_);function ke(e){return e}function Ke(e){return e}0&&(0);
//

/***/ }),

/***/ 2812:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



if (true) {
  module.exports = __webpack_require__(5325)
} else {}

/***/ }),

/***/ 6461:
/***/ ((module) => {

"use strict";
/* eslint-disable yoda */


const isFullwidthCodePoint = codePoint => {
	if (Number.isNaN(codePoint)) {
		return false;
	}

	// Code points are derived from:
	// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
	if (
		codePoint >= 0x1100 && (
			codePoint <= 0x115F || // Hangul Jamo
			codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
			codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
			// CJK Radicals Supplement .. Enclosed CJK Letters and Months
			(0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F) ||
			// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
			(0x3250 <= codePoint && codePoint <= 0x4DBF) ||
			// CJK Unified Ideographs .. Yi Radicals
			(0x4E00 <= codePoint && codePoint <= 0xA4C6) ||
			// Hangul Jamo Extended-A
			(0xA960 <= codePoint && codePoint <= 0xA97C) ||
			// Hangul Syllables
			(0xAC00 <= codePoint && codePoint <= 0xD7A3) ||
			// CJK Compatibility Ideographs
			(0xF900 <= codePoint && codePoint <= 0xFAFF) ||
			// Vertical Forms
			(0xFE10 <= codePoint && codePoint <= 0xFE19) ||
			// CJK Compatibility Forms .. Small Form Variants
			(0xFE30 <= codePoint && codePoint <= 0xFE6B) ||
			// Halfwidth and Fullwidth Forms
			(0xFF01 <= codePoint && codePoint <= 0xFF60) ||
			(0xFFE0 <= codePoint && codePoint <= 0xFFE6) ||
			// Kana Supplement
			(0x1B000 <= codePoint && codePoint <= 0x1B001) ||
			// Enclosed Ideographic Supplement
			(0x1F200 <= codePoint && codePoint <= 0x1F251) ||
			// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
			(0x20000 <= codePoint && codePoint <= 0x3FFFD)
		)
	) {
		return true;
	}

	return false;
};

module.exports = isFullwidthCodePoint;
module.exports["default"] = isFullwidthCodePoint;


/***/ }),

/***/ 5582:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const stripAnsi = __webpack_require__(9436);
const isFullwidthCodePoint = __webpack_require__(6461);
const emojiRegex = __webpack_require__(1354);

const stringWidth = string => {
	if (typeof string !== 'string' || string.length === 0) {
		return 0;
	}

	string = stripAnsi(string);

	if (string.length === 0) {
		return 0;
	}

	string = string.replace(emojiRegex(), '  ');

	let width = 0;

	for (let i = 0; i < string.length; i++) {
		const code = string.codePointAt(i);

		// Ignore control characters
		if (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {
			continue;
		}

		// Ignore combining characters
		if (code >= 0x300 && code <= 0x36F) {
			continue;
		}

		// Surrogates
		if (code > 0xFFFF) {
			i++;
		}

		width += isFullwidthCodePoint(code) ? 2 : 1;
	}

	return width;
};

module.exports = stringWidth;
// TODO: remove this in the next major version
module.exports["default"] = stringWidth;


/***/ }),

/***/ 9436:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ansiRegex = __webpack_require__(1371);

module.exports = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;


/***/ }),

/***/ 7935:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const stringWidth = __webpack_require__(5582);

const widestLine = input => {
	let max = 0;

	for (const line of input.split('\n')) {
		max = Math.max(max, stringWidth(line));
	}

	return max;
};

module.exports = widestLine;
// TODO: remove this in the next major version
module.exports["default"] = widestLine;


/***/ }),

/***/ 7830:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const stringWidth = __webpack_require__(5582);
const stripAnsi = __webpack_require__(9436);
const ansiStyles = __webpack_require__(6462);

const ESCAPES = new Set([
	'\u001B',
	'\u009B'
]);

const END_CODE = 39;

const ANSI_ESCAPE_BELL = '\u0007';
const ANSI_CSI = '[';
const ANSI_OSC = ']';
const ANSI_SGR_TERMINATOR = 'm';
const ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;

const wrapAnsi = code => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
const wrapAnsiHyperlink = uri => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;

// Calculate the length of words split on ' ', ignoring
// the extra characters added by ansi escape codes
const wordLengths = string => string.split(' ').map(character => stringWidth(character));

// Wrap a long word across multiple rows
// Ansi escape codes do not count towards length
const wrapWord = (rows, word, columns) => {
	const characters = [...word];

	let isInsideEscape = false;
	let isInsideLinkEscape = false;
	let visible = stringWidth(stripAnsi(rows[rows.length - 1]));

	for (const [index, character] of characters.entries()) {
		const characterLength = stringWidth(character);

		if (visible + characterLength <= columns) {
			rows[rows.length - 1] += character;
		} else {
			rows.push(character);
			visible = 0;
		}

		if (ESCAPES.has(character)) {
			isInsideEscape = true;
			isInsideLinkEscape = characters.slice(index + 1).join('').startsWith(ANSI_ESCAPE_LINK);
		}

		if (isInsideEscape) {
			if (isInsideLinkEscape) {
				if (character === ANSI_ESCAPE_BELL) {
					isInsideEscape = false;
					isInsideLinkEscape = false;
				}
			} else if (character === ANSI_SGR_TERMINATOR) {
				isInsideEscape = false;
			}

			continue;
		}

		visible += characterLength;

		if (visible === columns && index < characters.length - 1) {
			rows.push('');
			visible = 0;
		}
	}

	// It's possible that the last row we copy over is only
	// ansi escape characters, handle this edge-case
	if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
		rows[rows.length - 2] += rows.pop();
	}
};

// Trims spaces from a string ignoring invisible sequences
const stringVisibleTrimSpacesRight = string => {
	const words = string.split(' ');
	let last = words.length;

	while (last > 0) {
		if (stringWidth(words[last - 1]) > 0) {
			break;
		}

		last--;
	}

	if (last === words.length) {
		return string;
	}

	return words.slice(0, last).join(' ') + words.slice(last).join('');
};

// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode
//
// 'hard' will never allow a string to take up more than columns characters
//
// 'soft' allows long words to expand past the column length
const exec = (string, columns, options = {}) => {
	if (options.trim !== false && string.trim() === '') {
		return '';
	}

	let returnValue = '';
	let escapeCode;
	let escapeUrl;

	const lengths = wordLengths(string);
	let rows = [''];

	for (const [index, word] of string.split(' ').entries()) {
		if (options.trim !== false) {
			rows[rows.length - 1] = rows[rows.length - 1].trimStart();
		}

		let rowLength = stringWidth(rows[rows.length - 1]);

		if (index !== 0) {
			if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
				// If we start with a new word but the current row length equals the length of the columns, add a new row
				rows.push('');
				rowLength = 0;
			}

			if (rowLength > 0 || options.trim === false) {
				rows[rows.length - 1] += ' ';
				rowLength++;
			}
		}

		// In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'
		if (options.hard && lengths[index] > columns) {
			const remainingColumns = (columns - rowLength);
			const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
			const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
			if (breaksStartingNextLine < breaksStartingThisLine) {
				rows.push('');
			}

			wrapWord(rows, word, columns);
			continue;
		}

		if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
			if (options.wordWrap === false && rowLength < columns) {
				wrapWord(rows, word, columns);
				continue;
			}

			rows.push('');
		}

		if (rowLength + lengths[index] > columns && options.wordWrap === false) {
			wrapWord(rows, word, columns);
			continue;
		}

		rows[rows.length - 1] += word;
	}

	if (options.trim !== false) {
		rows = rows.map(stringVisibleTrimSpacesRight);
	}

	const pre = [...rows.join('\n')];

	for (const [index, character] of pre.entries()) {
		returnValue += character;

		if (ESCAPES.has(character)) {
			const {groups} = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(pre.slice(index).join('')) || {groups: {}};
			if (groups.code !== undefined) {
				const code = Number.parseFloat(groups.code);
				escapeCode = code === END_CODE ? undefined : code;
			} else if (groups.uri !== undefined) {
				escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;
			}
		}

		const code = ansiStyles.codes.get(Number(escapeCode));

		if (pre[index + 1] === '\n') {
			if (escapeUrl) {
				returnValue += wrapAnsiHyperlink('');
			}

			if (escapeCode && code) {
				returnValue += wrapAnsi(code);
			}
		} else if (character === '\n') {
			if (escapeCode && code) {
				returnValue += wrapAnsi(escapeCode);
			}

			if (escapeUrl) {
				returnValue += wrapAnsiHyperlink(escapeUrl);
			}
		}
	}

	return returnValue;
};

// For each newline, invoke the method separately
module.exports = (string, columns, options) => {
	return String(string)
		.normalize()
		.replace(/\r\n/g, '\n')
		.split('\n')
		.map(line => exec(line, columns, options))
		.join('\n');
};


/***/ }),

/***/ 7442:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZodError = exports.quotelessJson = exports.ZodIssueCode = void 0;
const util_1 = __webpack_require__(4705);
exports.ZodIssueCode = util_1.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
exports.quotelessJson = quotelessJson;
class ZodError extends Error {
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    get errors() {
        return this.issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
exports.ZodError = ZodError;
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};


/***/ }),

/***/ 548:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getErrorMap = exports.setErrorMap = exports.defaultErrorMap = void 0;
const en_1 = __importDefault(__webpack_require__(8412));
exports.defaultErrorMap = en_1.default;
let overrideErrorMap = en_1.default;
function setErrorMap(map) {
    overrideErrorMap = map;
}
exports.setErrorMap = setErrorMap;
function getErrorMap() {
    return overrideErrorMap;
}
exports.getErrorMap = getErrorMap;


/***/ }),

/***/ 6340:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(548), exports);
__exportStar(__webpack_require__(6258), exports);
__exportStar(__webpack_require__(9201), exports);
__exportStar(__webpack_require__(4705), exports);
__exportStar(__webpack_require__(5226), exports);
__exportStar(__webpack_require__(7442), exports);


/***/ }),

/***/ 5759:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorUtil = void 0;
var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil = exports.errorUtil || (exports.errorUtil = {}));


/***/ }),

/***/ 6258:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;
const errors_1 = __webpack_require__(548);
const en_1 = __importDefault(__webpack_require__(8412));
const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage,
    };
};
exports.makeIssue = makeIssue;
exports.EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const issue = (0, exports.makeIssue)({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            (0, errors_1.getErrorMap)(),
            en_1.default, // then global default map
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
exports.addIssueToContext = addIssueToContext;
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return exports.INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            syncPairs.push({
                key: await pair.key,
                value: await pair.value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return exports.INVALID;
            if (value.status === "aborted")
                return exports.INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (key.value !== "__proto__" &&
                (typeof value.value !== "undefined" || pair.alwaysSet)) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
exports.ParseStatus = ParseStatus;
exports.INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
exports.DIRTY = DIRTY;
const OK = (value) => ({ status: "valid", value });
exports.OK = OK;
const isAborted = (x) => x.status === "aborted";
exports.isAborted = isAborted;
const isDirty = (x) => x.status === "dirty";
exports.isDirty = isDirty;
const isValid = (x) => x.status === "valid";
exports.isValid = isValid;
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
exports.isAsync = isAsync;


/***/ }),

/***/ 9201:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 4705:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
var util;
(function (util) {
    util.assertEqual = (val) => val;
    function assertIs(_arg) { }
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array
            .map((val) => (typeof val === "string" ? `'${val}'` : val))
            .join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util = exports.util || (exports.util = {}));
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second, // second overwrites first
        };
    };
})(objectUtil = exports.objectUtil || (exports.objectUtil = {}));
exports.ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return exports.ZodParsedType.undefined;
        case "string":
            return exports.ZodParsedType.string;
        case "number":
            return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
        case "boolean":
            return exports.ZodParsedType.boolean;
        case "function":
            return exports.ZodParsedType.function;
        case "bigint":
            return exports.ZodParsedType.bigint;
        case "symbol":
            return exports.ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return exports.ZodParsedType.array;
            }
            if (data === null) {
                return exports.ZodParsedType.null;
            }
            if (data.then &&
                typeof data.then === "function" &&
                data.catch &&
                typeof data.catch === "function") {
                return exports.ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return exports.ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return exports.ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return exports.ZodParsedType.date;
            }
            return exports.ZodParsedType.object;
        default:
            return exports.ZodParsedType.unknown;
    }
};
exports.getParsedType = getParsedType;


/***/ }),

/***/ 5995:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.z = void 0;
const z = __importStar(__webpack_require__(6340));
exports.z = z;
__exportStar(__webpack_require__(6340), exports);
exports["default"] = z;


/***/ }),

/***/ 8412:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_1 = __webpack_require__(4705);
const ZodError_1 = __webpack_require__(7442);
const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodError_1.ZodIssueCode.invalid_type:
            if (issue.received === util_1.ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodError_1.ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
            break;
        case ZodError_1.ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodError_1.ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodError_1.ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
            break;
        case ZodError_1.ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodError_1.ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodError_1.ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodError_1.ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodError_1.ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                }
                else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    util_1.util.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodError_1.ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${new Date(Number(issue.minimum))}`;
            else
                message = "Invalid input";
            break;
        case ZodError_1.ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
                message = `BigInt must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `smaller than or equal to`
                        : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
                message = "Invalid input";
            break;
        case ZodError_1.ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodError_1.ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodError_1.ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodError_1.ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util_1.util.assertNever(issue);
    }
    return { message };
};
exports["default"] = errorMap;


/***/ }),

/***/ 5226:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.date = exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.custom = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.ZodType = void 0;
exports.NEVER = exports["void"] = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports["null"] = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports["instanceof"] = exports["function"] = exports["enum"] = exports.effect = exports.discriminatedUnion = void 0;
const errors_1 = __webpack_require__(548);
const errorUtil_1 = __webpack_require__(5759);
const parseUtil_1 = __webpack_require__(6258);
const util_1 = __webpack_require__(4705);
const ZodError_1 = __webpack_require__(7442);
class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
                this._cachedPath.push(...this._path, ...this._key);
            }
            else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result) => {
    if ((0, parseUtil_1.isValid)(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error() {
                if (this._error)
                    return this._error;
                const error = new ZodError_1.ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            },
        };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined") {
            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
        }
        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
    }
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return (0, util_1.getParsedType)(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new parseUtil_1.ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: (0, util_1.getParsedType)(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if ((0, parseUtil_1.isAsync)(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, util_1.getParsedType)(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, util_1.getParsedType)(data),
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult)
            ? maybeAsyncResult
            : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodError_1.ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function"
                    ? refinementData(val, ctx)
                    : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this, this._def);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def),
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
exports.ZodType = ZodType;
exports.Schema = ZodType;
exports.ZodSchema = ZodType;
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
// const uuidRegex =
//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
// const emailRegex =
//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// const emailRegex =
//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// const emailRegex =
//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
// const emailRegex =
//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
// Adapted from https://stackoverflow.com/a/3143231
const datetimeRegex = (args) => {
    if (args.precision) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
    }
    else if (args.precision === 0) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
    }
    else {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
    }
};
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.string,
                received: ctx.parsedType,
            }
            //
            );
            return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        (0, parseUtil_1.addIssueToContext)(ctx, {
                            code: ZodError_1.ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    else if (tooSmall) {
                        (0, parseUtil_1.addIssueToContext)(ctx, {
                            code: ZodError_1.ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "email",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "emoji") {
                if (!emojiRegex) {
                    emojiRegex = new RegExp(_emojiRegex, "u");
                }
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "emoji",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "uuid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "cuid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "cuid2",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "ulid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "url",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "regex",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: { includes: check.value, position: check.position },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            }
            else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            }
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "ip",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util_1.util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
            validation,
            code: ZodError_1.ZodIssueCode.invalid_string,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
    }
    datetime(options) {
        var _a;
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                message: options,
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options === null || options === void 0 ? void 0 : options.position,
            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(message) {
        return this.min(1, errorUtil_1.errorUtil.errToObj(message));
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
        });
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
exports.ZodString = ZodString;
ZodString.create = (params) => {
    var _a;
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.number,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        let ctx = undefined;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util_1.util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_finite,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util_1.util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil_1.errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil_1.errorUtil.toString(message),
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" ||
            (ch.kind === "multipleOf" && util_1.util.isInteger(ch.value)));
    }
    get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "finite" ||
                ch.kind === "int" ||
                ch.kind === "multipleOf") {
                return true;
            }
            else if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
            else if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
exports.ZodNumber = ZodNumber;
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.bigint) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.bigint,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        let ctx = undefined;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util_1.util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil_1.errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
exports.ZodBigInt = ZodBigInt;
ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodBoolean = ZodBoolean;
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.date,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_date,
            });
            return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else {
                util_1.util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
exports.ZodDate = ZodDate;
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.symbol,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodSymbol = ZodSymbol;
ZodSymbol.create = (params) => {
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodUndefined = ZodUndefined;
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.null,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodNull = ZodNull;
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodAny = ZodAny;
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodUnknown = ZodUnknown;
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.never,
            received: ctx.parsedType,
        });
        return parseUtil_1.INVALID;
    }
}
exports.ZodNever = ZodNever;
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.void,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodVoid = ZodVoid;
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.array,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
                    minimum: (tooSmall ? def.exactLength.value : undefined),
                    maximum: (tooBig ? def.exactLength.value : undefined),
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message,
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return parseUtil_1.ParseStatus.mergeArray(status, result);
            });
        }
        const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return parseUtil_1.ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
exports.ZodArray = ZodArray;
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element),
        });
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */
        this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util_1.util.objectKeys(shape);
        return (this._cached = { shape, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.object,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever &&
            this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") {
            }
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    syncPairs.push({
                        key,
                        value: await pair.value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil_1.errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...augmentation,
            }),
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...merging._def.shape(),
            }),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        util_1.util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    /**
     * @deprecated
     */
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            }
            else {
                newShape[key] = fieldSchema.optional();
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            }
            else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(util_1.util.objectKeys(this.shape));
    }
}
exports.ZodObject = ZodObject;
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union,
                unionErrors,
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError_1.ZodError(issues));
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union,
                unionErrors,
            });
            return parseUtil_1.INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
exports.ZodUnion = ZodUnion;
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    }
    else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    }
    else if (type instanceof ZodLiteral) {
        return [type.value];
    }
    else if (type instanceof ZodEnum) {
        return type.options;
    }
    else if (type instanceof ZodNativeEnum) {
        // eslint-disable-next-line ban/ban
        return Object.keys(type.enum);
    }
    else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    }
    else if (type instanceof ZodUndefined) {
        return [undefined];
    }
    else if (type instanceof ZodNull) {
        return [null];
    }
    else {
        return null;
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.object,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [discriminator],
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params),
        });
    }
}
exports.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
function mergeValues(a, b) {
    const aType = (0, util_1.getParsedType)(a);
    const bType = (0, util_1.getParsedType)(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
        const bKeys = util_1.util.objectKeys(b);
        const sharedKeys = util_1.util
            .objectKeys(a)
            .filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === util_1.ZodParsedType.date &&
        bType === util_1.ZodParsedType.date &&
        +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
                return parseUtil_1.INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.invalid_intersection_types,
                });
                return parseUtil_1.INVALID;
            }
            if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
exports.ZodIntersection = ZodIntersection;
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.array,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            return parseUtil_1.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            status.dirty();
        }
        const items = [...ctx.data]
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return parseUtil_1.ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return parseUtil_1.ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
exports.ZodTuple = ZodTuple;
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.object,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            });
        }
        if (ctx.common.async) {
            return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
exports.ZodRecord = ZodRecord;
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.map) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.map,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return parseUtil_1.INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return parseUtil_1.INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
exports.ZodMap = ZodMap;
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.set) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.set,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return parseUtil_1.INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
exports.ZodSet = ZodSet;
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.function) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.function,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        function makeArgsIssue(args, error) {
            return (0, parseUtil_1.makeIssue)({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, errors_1.getErrorMap)(),
                    errors_1.defaultErrorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodError_1.ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return (0, parseUtil_1.makeIssue)({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, errors_1.getErrorMap)(),
                    errors_1.defaultErrorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodError_1.ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return (0, parseUtil_1.OK)(async function (...args) {
                const error = new ZodError_1.ZodError([]);
                const parsedArgs = await me._def.args
                    .parseAsync(args, params)
                    .catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return (0, parseUtil_1.OK)(function (...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: (args
                ? args
                : ZodTuple.create([]).rest(ZodUnknown.create())),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params),
        });
    }
}
exports.ZodFunction = ZodFunction;
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
exports.ZodLazy = ZodLazy;
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
exports.ZodLiteral = ZodLiteral;
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, parseUtil_1.addIssueToContext)(ctx, {
                expected: util_1.util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodError_1.ZodIssueCode.invalid_type,
            });
            return parseUtil_1.INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values) {
        return ZodEnum.create(values);
    }
    exclude(values) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
    }
}
exports.ZodEnum = ZodEnum;
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_1.ZodParsedType.string &&
            ctx.parsedType !== util_1.ZodParsedType.number) {
            const expectedValues = util_1.util.objectValues(nativeEnumValues);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                expected: util_1.util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodError_1.ZodIssueCode.invalid_type,
            });
            return parseUtil_1.INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util_1.util.objectValues(nativeEnumValues);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
exports.ZodNativeEnum = ZodNativeEnum;
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.promise &&
            ctx.common.async === false) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const promisified = ctx.parsedType === util_1.ZodParsedType.promise
            ? ctx.data
            : Promise.resolve(ctx.data);
        return (0, parseUtil_1.OK)(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
exports.ZodPromise = ZodPromise;
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg) => {
                (0, parseUtil_1.addIssueToContext)(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.issues.length) {
                return {
                    status: "dirty",
                    value: ctx.data,
                };
            }
            if (ctx.common.async) {
                return Promise.resolve(processed).then((processed) => {
                    return this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                });
            }
            else {
                return this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc
            // effect: RefinementEffect<any>
            ) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return parseUtil_1.INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((inner) => {
                    if (inner.status === "aborted")
                        return parseUtil_1.INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (!(0, parseUtil_1.isValid)(base))
                    return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((base) => {
                    if (!(0, parseUtil_1.isValid)(base))
                        return base;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        util_1.util.assertNever(effect);
    }
}
exports.ZodEffects = ZodEffects;
exports.ZodTransformer = ZodEffects;
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.undefined) {
            return (0, parseUtil_1.OK)(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
exports.ZodOptional = ZodOptional;
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.null) {
            return (0, parseUtil_1.OK)(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
exports.ZodNullable = ZodNullable;
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === util_1.ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
exports.ZodDefault = ZodDefault;
ZodDefault.create = (type, params) => {
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function"
            ? params.default
            : () => params.default,
        ...processCreateParams(params),
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: [],
            },
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx,
            },
        });
        if ((0, parseUtil_1.isAsync)(result)) {
            return result.then((result) => {
                return {
                    status: "valid",
                    value: result.status === "valid"
                        ? result.value
                        : this._def.catchValue({
                            get error() {
                                return new ZodError_1.ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data,
                        }),
                };
            });
        }
        else {
            return {
                status: "valid",
                value: result.status === "valid"
                    ? result.value
                    : this._def.catchValue({
                        get error() {
                            return new ZodError_1.ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data,
                    }),
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
exports.ZodCatch = ZodCatch;
ZodCatch.create = (type, params) => {
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
exports.ZodNaN = ZodNaN;
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
exports.BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
exports.ZodBranded = ZodBranded;
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async () => {
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted")
                    return parseUtil_1.INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return (0, parseUtil_1.DIRTY)(inResult.value);
                }
                else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            };
            return handleAsync();
        }
        else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
            if (inResult.status === "aborted")
                return parseUtil_1.INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value,
                };
            }
            else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline,
        });
    }
}
exports.ZodPipeline = ZodPipeline;
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        if ((0, parseUtil_1.isValid)(result)) {
            result.value = Object.freeze(result.value);
        }
        return result;
    }
}
exports.ZodReadonly = ZodReadonly;
ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params),
    });
};
const custom = (check, params = {}, 
/**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */
fatal) => {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            var _a, _b;
            if (!check(data)) {
                const p = typeof params === "function"
                    ? params(data)
                    : typeof params === "string"
                        ? { message: params }
                        : params;
                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                const p2 = typeof p === "string" ? { message: p } : p;
                ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
            }
        });
    return ZodAny.create();
};
exports.custom = custom;
exports.late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind = exports.ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = {}));
// requires TS 4.4+
class Class {
    constructor(..._) { }
}
const instanceOfType = (
// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => (0, exports.custom)((data) => data instanceof cls, params);
exports["instanceof"] = instanceOfType;
const stringType = ZodString.create;
exports.string = stringType;
const numberType = ZodNumber.create;
exports.number = numberType;
const nanType = ZodNaN.create;
exports.nan = nanType;
const bigIntType = ZodBigInt.create;
exports.bigint = bigIntType;
const booleanType = ZodBoolean.create;
exports.boolean = booleanType;
const dateType = ZodDate.create;
exports.date = dateType;
const symbolType = ZodSymbol.create;
exports.symbol = symbolType;
const undefinedType = ZodUndefined.create;
exports.undefined = undefinedType;
const nullType = ZodNull.create;
exports["null"] = nullType;
const anyType = ZodAny.create;
exports.any = anyType;
const unknownType = ZodUnknown.create;
exports.unknown = unknownType;
const neverType = ZodNever.create;
exports.never = neverType;
const voidType = ZodVoid.create;
exports["void"] = voidType;
const arrayType = ZodArray.create;
exports.array = arrayType;
const objectType = ZodObject.create;
exports.object = objectType;
const strictObjectType = ZodObject.strictCreate;
exports.strictObject = strictObjectType;
const unionType = ZodUnion.create;
exports.union = unionType;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
exports.discriminatedUnion = discriminatedUnionType;
const intersectionType = ZodIntersection.create;
exports.intersection = intersectionType;
const tupleType = ZodTuple.create;
exports.tuple = tupleType;
const recordType = ZodRecord.create;
exports.record = recordType;
const mapType = ZodMap.create;
exports.map = mapType;
const setType = ZodSet.create;
exports.set = setType;
const functionType = ZodFunction.create;
exports["function"] = functionType;
const lazyType = ZodLazy.create;
exports.lazy = lazyType;
const literalType = ZodLiteral.create;
exports.literal = literalType;
const enumType = ZodEnum.create;
exports["enum"] = enumType;
const nativeEnumType = ZodNativeEnum.create;
exports.nativeEnum = nativeEnumType;
const promiseType = ZodPromise.create;
exports.promise = promiseType;
const effectsType = ZodEffects.create;
exports.effect = effectsType;
exports.transformer = effectsType;
const optionalType = ZodOptional.create;
exports.optional = optionalType;
const nullableType = ZodNullable.create;
exports.nullable = nullableType;
const preprocessType = ZodEffects.createWithPreprocess;
exports.preprocess = preprocessType;
const pipelineType = ZodPipeline.create;
exports.pipeline = pipelineType;
const ostring = () => stringType().optional();
exports.ostring = ostring;
const onumber = () => numberType().optional();
exports.onumber = onumber;
const oboolean = () => booleanType().optional();
exports.oboolean = oboolean;
exports.coerce = {
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true,
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
};
exports.NEVER = parseUtil_1.INVALID;


/***/ }),

/***/ 3696:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LMStudioClient = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_diagnostics_backend_interface_1 = __webpack_require__(7364);
const lms_isomorphic_1 = __webpack_require__(390);
const lms_llm_backend_interface_1 = __webpack_require__(6853);
const lms_system_backend_interface_1 = __webpack_require__(8103);
const chalk_1 = __importDefault(__webpack_require__(8033));
const process_1 = __importDefault(__webpack_require__(9771));
const zod_1 = __webpack_require__(5995);
const createAuthenticatedClientPort_1 = __webpack_require__(9531);
const DiagnosticsNamespace_1 = __webpack_require__(2204);
const friendlyErrorDeserializer_1 = __webpack_require__(8488);
const LLMNamespace_1 = __webpack_require__(2392);
const SystemNamespace_1 = __webpack_require__(4600);
const constructorOptsSchema = zod_1.z
    .object({
    logger: zod_1.z.any().optional(),
    baseUrl: zod_1.z.string().optional(),
    verboseErrorMessages: zod_1.z.boolean().optional(),
    clientIdentifier: zod_1.z.string().optional(),
    clientPasskey: zod_1.z.string().optional(),
})
    .strict();
/** @public */
class LMStudioClient {
    /** @internal */
    validateBaseUrlOrThrow(baseUrl) {
        let url;
        try {
            url = new URL(baseUrl);
        }
        catch (e) {
            this.logger.throw((0, lms_common_1.text) `
        Failed to construct LMStudioClient. The baseUrl passed in is invalid. Received: ${baseUrl}
      `);
        }
        if (!["ws:", "wss:"].includes(url.protocol)) {
            this.logger.throw((0, lms_common_1.text) `
        Failed to construct LMStudioClient. The baseUrl passed in must have protocol "ws" or "wss". 
        Received: ${baseUrl}
      `);
        }
        if (url.search !== "") {
            this.logger.throw((0, lms_common_1.text) `
        Failed to construct LMStudioClient. The baseUrl passed contains search parameters
        ("${url.search}").
      `);
        }
        if (url.hash !== "") {
            this.logger.throw((0, lms_common_1.text) `
        Failed to construct LMStudioClient. The baseUrl passed contains a hash ("${url.hash}").
      `);
        }
        if (url.username !== "" || url.password !== "") {
            this.logger.throw((0, lms_common_1.text) `
        Failed to construct LMStudioClient. The baseUrl passed contains a username or password. We
        do not support these in the baseUrl. Received: ${baseUrl}
      `);
        }
        if (baseUrl.endsWith("/")) {
            this.logger.throw((0, lms_common_1.text) `
        Failed to construct LMStudioClient. The baseUrl passed in must not end with a "/". If you
        are reverse-proxying, you should remove the trailing slash from the baseUrl. Received:
        ${baseUrl}
      `);
        }
    }
    async isLocalhostWithGivenPortLMStudioServer(port) {
        const response = await fetch(`http://127.0.0.1:${port}/lmstudio-greeting`);
        if (response.status !== 200) {
            throw new Error("Status is not 200.");
        }
        const json = await response.json();
        if (json?.lmstudio !== true) {
            throw new Error("Not an LM Studio server.");
        }
        return port;
    }
    /**
     * Guess the base URL of the LM Studio server by visiting localhost on various default ports.
     */
    async guessBaseUrl(stack) {
        return Promise.any(lms_common_1.lmsDefaultPorts.map(this.isLocalhostWithGivenPortLMStudioServer)).then(port => `ws://127.0.0.1:${port}`, () => {
            throw (0, lms_common_1.makePrettyError)((0, lms_common_1.text) `
            ${chalk_1.default.redBright("Failed to connect to LM Studio on the default port (1234).")}

            Is LM Studio running? If not, you can start it by running:

                ${chalk_1.default.yellow("lms server start" + (process_1.default.browser ? " --cors=true" : ""))}

            ${chalk_1.default.white("(i) For more information, refer to the LM Studio documentation:")}

                ${chalk_1.default.gray("https://lmstudio.ai/docs/local-server")}
          `, stack);
            // console.error(text`
            //   ${chalk.blueBright(text`
            //      HINT: If you are using a custom port and/or are reverse-proxying, you should pass the
            //     base URL to the LMStudioClient constructor like so:
            //   `)}
            //       ${chalk.cyanBright(text`
            //         const client = new LMStudioClient({ baseUrl: "ws://127.0.0.1:<PORT>" });
            //       `)}
            // `);
            // // We just want to return a promise that never resolves.
            // // This blocks all the API calls.
            // return new Promise(() => undefined);
        });
    }
    constructor(opts = {}) {
        const { logger, baseUrl, verboseErrorMessages, clientIdentifier, clientPasskey } = new lms_common_1.Validator().validateConstructorParamOrThrow("LMStudioClient", "opts", constructorOptsSchema, opts);
        this.logger = new lms_common_1.SimpleLogger("LMStudioClient", logger);
        this.clientIdentifier = clientIdentifier ?? (0, lms_isomorphic_1.generateRandomBase64)(18);
        this.clientPasskey = clientPasskey ?? (0, lms_isomorphic_1.generateRandomBase64)(18);
        const stack = (0, lms_common_1.getCurrentStack)(1);
        let resolvingBaseUrl;
        if (baseUrl === undefined) {
            resolvingBaseUrl = this.guessBaseUrl(verboseErrorMessages ? stack : undefined);
        }
        else {
            this.validateBaseUrlOrThrow(baseUrl);
            resolvingBaseUrl = baseUrl;
        }
        this.llmPort = (0, createAuthenticatedClientPort_1.createAuthenticatedClientPort)((0, lms_llm_backend_interface_1.createLlmBackendInterface)(), resolvingBaseUrl, "llm", this.clientIdentifier, this.clientPasskey, new lms_common_1.SimpleLogger("LLM", this.logger), {
            errorDeserializer: friendlyErrorDeserializer_1.friendlyErrorDeserializer,
            verboseErrorMessage: verboseErrorMessages ?? false,
        });
        this.systemPort = (0, createAuthenticatedClientPort_1.createAuthenticatedClientPort)((0, lms_system_backend_interface_1.createSystemBackendInterface)(), resolvingBaseUrl, "system", this.clientIdentifier, this.clientPasskey, new lms_common_1.SimpleLogger("System", this.logger), {
            errorDeserializer: friendlyErrorDeserializer_1.friendlyErrorDeserializer,
            verboseErrorMessage: verboseErrorMessages ?? false,
        });
        this.diagnosticsPort = (0, createAuthenticatedClientPort_1.createAuthenticatedClientPort)((0, lms_diagnostics_backend_interface_1.createDiagnosticsBackendInterface)(), resolvingBaseUrl, "diagnostics", this.clientIdentifier, this.clientPasskey, new lms_common_1.SimpleLogger("Diagnostics", this.logger), {
            errorDeserializer: friendlyErrorDeserializer_1.friendlyErrorDeserializer,
            verboseErrorMessage: verboseErrorMessages ?? false,
        });
        const validator = new lms_common_1.Validator();
        this.llm = new LLMNamespace_1.LLMNamespace(this.llmPort, validator, this.logger);
        this.system = new SystemNamespace_1.SystemNamespace(this.systemPort, this.logger);
        this.diagnostics = new DiagnosticsNamespace_1.DiagnosticsNamespace(this.diagnosticsPort, validator, this.logger);
    }
}
exports.LMStudioClient = LMStudioClient;
//

/***/ }),

/***/ 9531:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createAuthenticatedClientPort = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_communication_client_1 = __webpack_require__(3697);
function createAuthenticatedIpcTransportFactory(apiNamespace, hostedEnv, clientIdentifier, clientPasskey) {
    const [onMessage, emitOnMessage] = lms_common_1.BufferedEvent.create();
    const [onClose, emitOnClose] = lms_common_1.BufferedEvent.create();
    const sendToServer = hostedEnv.getApiIpcTunnel(apiNamespace, {
        authVersion: 1,
        clientIdentifier: clientIdentifier,
        clientPasskey: clientPasskey,
    }, emitOnMessage, emitOnClose);
    return lms_communication_client_1.GenericClientTransport.createFactory(onMessage, onClose, sendToServer);
}
function createAuthenticatedWsTransportFactory(apiNamespace, wsAddress, clientIdentifier, clientPasskey) {
    return lms_communication_client_1.AuthenticatedWsClientTransport.createAuthenticatedWsClientTransportFactory({
        url: Promise.resolve(wsAddress).then(wsAddress => `${wsAddress}/${apiNamespace}`),
        clientIdentifier: clientIdentifier,
        clientPasskey: clientPasskey,
    });
}
function createAuthenticatedClientPort(backendInterface, wsAddress, apiNamespace, clientIdentifier, clientPasskey, logger, { errorDeserializer, verboseErrorMessage, } = {}) {
    let anyWindow;
    try {
        anyWindow = window;
    }
    catch (error) {
        anyWindow = undefined;
    }
    if (anyWindow !== undefined && anyWindow.lmsHostedEnv !== undefined) {
        if (wsAddress !== undefined) {
            logger.debug("Ignoring wsAddress parameter when constructing the client because the client is" +
                " running in a hosted environment. This is not an error.");
        }
        return new lms_communication_client_1.ClientPort(backendInterface, createAuthenticatedIpcTransportFactory(apiNamespace, anyWindow.lmsHostedEnv, clientIdentifier, clientPasskey), { parentLogger: logger, errorDeserializer, verboseErrorMessage });
    }
    else {
        return new lms_communication_client_1.ClientPort(backendInterface, createAuthenticatedWsTransportFactory(apiNamespace, wsAddress, clientIdentifier, clientPasskey), { parentLogger: logger, errorDeserializer, verboseErrorMessage });
    }
}
exports.createAuthenticatedClientPort = createAuthenticatedClientPort;
//

/***/ }),

/***/ 2204:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticsNamespace = void 0;
const lms_common_1 = __webpack_require__(2934);
const zod_1 = __webpack_require__(5995);
/** @public */
class DiagnosticsNamespace {
    /** @internal */
    constructor(diagnosticsPort, validator, parentLogger) {
        this.diagnosticsPort = diagnosticsPort;
        this.validator = validator;
        this.logger = new lms_common_1.SimpleLogger("Diagnostics", parentLogger);
    }
    /**
     * Register a callback to receive log events. Return a function to stop receiving log events.
     *
     * This method is in alpha. Do not use this method in production yet.
     * @alpha
     */
    unstable_streamLogs(listener) {
        const stack = (0, lms_common_1.getCurrentStack)(1);
        this.validator.validateMethodParamOrThrow("client.diagnostics", "unstable_streamLogs", "listener", zod_1.z.function(), listener, stack);
        const channel = this.diagnosticsPort.createChannel("streamLogs", undefined, undefined, {
            stack,
        });
        const unsubscribe = channel.onMessage.subscribe(message => {
            if (message.type === "log") {
                listener(message.log);
            }
        });
        return () => {
            unsubscribe();
            channel.send({
                type: "stop",
            });
        };
    }
}
exports.DiagnosticsNamespace = DiagnosticsNamespace;
//

/***/ }),

/***/ 8488:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.friendlyErrorDeserializer = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_shared_types_1 = __webpack_require__(5790);
const chalk_1 = __importDefault(__webpack_require__(8033));
function deserializeOtherError(serialized, stack) {
    let content = chalk_1.default.bgRed.white(` ${serialized.title} `);
    if (serialized.suggestion !== undefined) {
        content +=
            "\n\n\n " +
                chalk_1.default.bgWhite.black("  (!) SUGGESTION  ") +
                "\n\n" +
                chalk_1.default.white(serialized.suggestion);
    }
    if (serialized.cause !== undefined) {
        content +=
            "\n\n\n " + chalk_1.default.bgWhite.black("  (X) CAUSE  ") + "\n\n" + chalk_1.default.gray(serialized.cause);
    }
    return (0, lms_common_1.makePrettyError)(content, stack);
}
const errorDeserializersMap = new Map();
function registerErrorDeserializer(code, deserializer) {
    errorDeserializersMap.set(code, deserializer);
}
function formatAvailableLLMs(availablePathsSample, totalModels) {
    if (availablePathsSample.length === 0) {
        return chalk_1.default.gray("    You don't have any LLMs downloaded.");
    }
    let text = availablePathsSample.map(path => chalk_1.default.cyanBright("  " + path)).join("\n");
    if (availablePathsSample.length < totalModels) {
        text += chalk_1.default.gray(`\n     ... (and ${totalModels - availablePathsSample.length} more)`);
    }
    return text;
}
registerErrorDeserializer("llm.pathNotFound", ({ availablePathsSample, path, totalModels }, stack) => {
    return (0, lms_common_1.makeTitledPrettyError)(`Cannot find an LLM with path "${chalk_1.default.yellowBright(path)}"`, (0, lms_common_1.text) `
        Here are your available LLMs:

        ${formatAvailableLLMs(availablePathsSample, totalModels)}

        Run

            ${chalk_1.default.yellowBright("lms ls")}

        to see a full list of loadable models
      `, stack);
});
function formatLoadedLLMs(loadedModelsSample, totalLoadedModels) {
    if (loadedModelsSample.length === 0) {
        return chalk_1.default.gray("    You don't have any LLMs loaded.");
    }
    let text = loadedModelsSample.map(path => chalk_1.default.cyanBright("  " + path)).join("\n");
    if (loadedModelsSample.length < totalLoadedModels) {
        text += chalk_1.default.gray(`\n     ... (and ${totalLoadedModels - loadedModelsSample.length} more)`);
    }
    return text;
}
registerErrorDeserializer("llm.identifierNotFound", ({ loadedModelsSample, identifier, totalLoadedModels }, stack) => {
    return (0, lms_common_1.makeTitledPrettyError)(`Cannot find an LLM with identifier "${chalk_1.default.yellowBright(identifier)}"`, (0, lms_common_1.text) `
        Here are your loaded LLMs:

        ${formatLoadedLLMs(loadedModelsSample, totalLoadedModels)}

        Run

            ${chalk_1.default.yellowBright("lms ps")}

        to see a full list of loaded models
      `, stack);
});
registerErrorDeserializer("llm.specificModelUnloaded", (_, stack) => {
    return (0, lms_common_1.makePrettyError)(chalk_1.default.bgRed.white((0, lms_common_1.text) `
    This model has already been unloaded.
  `), stack);
});
function formatQuery(query) {
    const requirements = [];
    if (query.identifier !== undefined) {
        requirements.push(`The identifier must be exactly "${chalk_1.default.yellowBright(query.identifier)}"`);
    }
    if (query.path !== undefined) {
        requirements.push(`The path must match "${chalk_1.default.yellowBright(query.path)}"`);
    }
    if (requirements.length === 0) {
        return chalk_1.default.gray("  Any LLM");
    }
    requirements.unshift("The model must be an LLM");
    return requirements.map(req => chalk_1.default.white("  " + req)).join("\n");
}
registerErrorDeserializer("llm.noModelMatchingQuery", ({ loadedModelsSample, totalLoadedModels }, stack) => {
    return (0, lms_common_1.makePrettyError)((0, lms_common_1.text) `
        ${chalk_1.default.bgRed.white(" No loaded LLM satisfies all requirements specified in the query. ")}

        Loaded LLMs:

        ${formatLoadedLLMs(loadedModelsSample, totalLoadedModels)}

        Run

            ${chalk_1.default.yellowBright("lms ps")}

        to see a full list of loaded models with details
      `, stack);
});
function friendlyErrorDeserializer(serialized, stack) {
    if (serialized.displayData === undefined) {
        return deserializeOtherError(serialized, stack);
    }
    let error;
    const specificDeserializer = errorDeserializersMap.get(serialized.displayData.code);
    if (specificDeserializer !== undefined) {
        error = specificDeserializer(serialized.displayData, stack);
        (0, lms_shared_types_1.attachSerializedErrorData)(error, serialized);
        return error;
    }
    else {
        return deserializeOtherError(serialized, stack);
    }
}
exports.friendlyErrorDeserializer = friendlyErrorDeserializer;
//

/***/ }),

/***/ 7412:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LMStudioClient = void 0;
var LMStudioClient_1 = __webpack_require__(3696);
Object.defineProperty(exports, "LMStudioClient", ({ enumerable: true, get: function () { return LMStudioClient_1.LMStudioClient; } }));
//

/***/ }),

/***/ 6552:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LLMDynamicHandle = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_shared_types_1 = __webpack_require__(5790);
const zod_1 = __webpack_require__(5995);
const OngoingPrediction_1 = __webpack_require__(864);
const completeOptsSchema = zod_1.z.object({
    ...lms_shared_types_1.llmCompletionPredictionConfigSchema.shape,
    structured: lms_shared_types_1.llmStructuredPredictionSettingSchema.optional(),
});
const respondOptsSchema = zod_1.z.object({
    ...lms_shared_types_1.llmChatPredictionConfigSchema.shape,
    structured: lms_shared_types_1.llmStructuredPredictionSettingSchema.optional(),
});
/**
 * This represents a set of requirements for a model. It is not tied to a specific model, but rather
 * to a set of requirements that a model must satisfy.
 *
 * For example, if you got the model via `client.llm.get("my-identifier")`, you will get a
 * `LLMModel` for the model with the identifier `my-identifier`. If the model is unloaded, and
 * another model is loaded with the same identifier, using the same `LLMModel` will use the new
 * model.
 *
 * @public
 */
class LLMDynamicHandle {
    /**
     * Don't construct this on your own. Use {@link LLMNamespace#get} or {@link LLMNamespace#load}
     * instead.
     *
     * @internal
     */
    constructor(
    /** @internal */
    llmPort, 
    /** @internal */
    specifier, 
    /** @internal */
    validator, 
    /** @internal */
    logger = new lms_common_1.SimpleLogger(`LLMModel`)) {
        this.llmPort = llmPort;
        this.specifier = specifier;
        this.validator = validator;
        this.logger = logger;
    }
    /** @internal */
    predict(modelSpecifier, history, config, structured, cancelEvent, onFragment, onFinished, onError) {
        const channel = this.llmPort.createChannel("predict", { modelSpecifier, history, config, structured }, message => {
            switch (message.type) {
                case "fragment":
                    onFragment(message.fragment);
                    break;
                case "success":
                    onFinished(message.stats, message.modelInfo);
                    break;
            }
        }, { stack: (0, lms_common_1.getCurrentStack)(2) });
        cancelEvent.subscribeOnce(() => {
            channel.send({ type: "cancel" });
        });
        channel.onError.subscribeOnce(onError);
    }
    /**
     * Use the loaded model to predict text.
     *
     * This method returns an {@link OngoingPrediction} object. An ongoing prediction can be used as a
     * promise (if you only care about the final result) or as an async iterable (if you want to
     * stream the results as they are being generated).
     *
     * Example usage as a promise (Resolves to a {@link PredictionResult}):
     *
     * ```typescript
     * const result = await model.complete("When will The Winds of Winter be released?");
     * console.log(result.content);
     * ```
     *
     * Or
     *
     * ```typescript
     * model.complete("When will The Winds of Winter be released?")
     *  .then(result =\> console.log(result.content))
     *  .catch(error =\> console.error(error));
     * ```
     *
     * Example usage as an async iterable (streaming):
     *
     * ```typescript
     * for await (const fragment of model.complete("When will The Winds of Winter be released?")) {
     *   process.stdout.write(fragment);
     * }
     * ```
     *
     * If you wish to stream the result, but also getting the final prediction results (for example,
     * you wish to get the prediction stats), you can use the following pattern:
     *
     * ```typescript
     * const prediction = model.complete("When will The Winds of Winter be released?");
     * for await (const fragment of prediction) {
     *   process.stdout.write(fragment);
     * }
     * const result = await prediction;
     * console.log(result.stats);
     * ```
     *
     * @param prompt - The prompt to use for prediction.
     * @param opts - Options for the prediction.
     */
    complete(prompt, opts = {}) {
        const stack = (0, lms_common_1.getCurrentStack)(1);
        [prompt, opts] = this.validator.validateMethodParamsOrThrow("model", "complete", ["prompt", "opts"], [zod_1.z.string(), completeOptsSchema], [prompt, opts], stack);
        const { structured, ...config } = opts;
        const [cancelEvent, emitCancelEvent] = lms_common_1.BufferedEvent.create();
        const { ongoingPrediction, finished, failed, push } = OngoingPrediction_1.OngoingPrediction.create(emitCancelEvent);
        this.predict(this.specifier, [{ role: "user", content: prompt }], {
            // If the user did not specify `stopStrings`, we default to an empty array. This is to
            // prevent the model from using the value set in the preset.
            stopStrings: [],
            // Same for pre-prompt
            prePrompt: "",
            ...config,
            // We don't allow the user to set `inputPrefix` and `inputSuffix` in `complete` because it
            // doesn't make sense to do so (and can be vastly confusing.) If the user wants to set these
            // values, they can just include them in the prompt. Here, we just set them to empty strings
            // to prevent the model from using the values set in the preset.
            inputPrefix: "",
            inputSuffix: "",
        }, structured, cancelEvent, fragment => push(fragment), (stats, modelInfo) => finished(stats, modelInfo), error => failed(error));
        return ongoingPrediction;
    }
    /**
     * Use the loaded model to generate a response based on the given history.
     *
     * This method returns an {@link OngoingPrediction} object. An ongoing prediction can be used as a
     * promise (if you only care about the final result) or as an async iterable (if you want to
     * stream the results as they are being generated).
     *
     * Example usage as a promise (Resolves to a {@link PredictionResult}):
     *
     * ```typescript
     * const history = [{ type: 'user', content: "When will The Winds of Winter be released?" }];
     * const result = await model.respond(history);
     * console.log(result.content);
     * ```
     *
     * Or
     *
     * ```typescript
     * const history = [{ type: 'user', content: "When will The Winds of Winter be released?" }];
     * model.respond(history)
     *  .then(result => console.log(result.content))
     *  .catch(error => console.error(error));
     * ```
     *
     * Example usage as an async iterable (streaming):
     *
     * ```typescript
     * const history = [{ type: 'user', content: "When will The Winds of Winter be released?" }];
     * for await (const fragment of model.respond(history)) {
     *   process.stdout.write(fragment);
     * }
     * ```
     *
     * If you wish to stream the result, but also getting the final prediction results (for example,
     * you wish to get the prediction stats), you can use the following pattern:
     *
     * ```typescript
     * const history = [{ type: 'user', content: "When will The Winds of Winter be released?" }];
     * const prediction = model.respond(history);
     * for await (const fragment of prediction) {
     *   process.stdout.write(fragment);
     * }
     * const result = await prediction;
     * console.log(result.stats);
     * ```
     *
     * @param history - The LLMChatHistory array to use for generating a response.
     * @param opts - Options for the prediction.
     */
    respond(history, opts = {}) {
        const stack = (0, lms_common_1.getCurrentStack)(1);
        [history, opts] = this.validator.validateMethodParamsOrThrow("model", "respond", ["history", "opts"], [lms_shared_types_1.llmChatHistorySchema, respondOptsSchema], [history, opts], stack);
        const { structured, ...config } = opts;
        const [cancelEvent, emitCancelEvent] = lms_common_1.BufferedEvent.create();
        const { ongoingPrediction, finished, failed, push } = OngoingPrediction_1.OngoingPrediction.create(emitCancelEvent);
        this.predict(this.specifier, history, config, structured, cancelEvent, fragment => push(fragment), (stats, modelInfo) => finished(stats, modelInfo), error => failed(error));
        return ongoingPrediction;
    }
    /**
     * Gets the information of the model that is currently associated with this `LLMModel`. If no
     * model is currently associated, this will return `undefined`.
     *
     * Note: As models are loaded/unloaded, the model associated with this `LLMModel` may change at
     * any moment.
     */
    async getModelInfo() {
        const info = await this.llmPort.callRpc("getModelInfo", { specifier: this.specifier, throwIfNotFound: false }, { stack: (0, lms_common_1.getCurrentStack)(1) });
        if (info === undefined) {
            return undefined;
        }
        return info.descriptor;
    }
}
exports.LLMDynamicHandle = LLMDynamicHandle;
//

/***/ }),

/***/ 2392:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LLMNamespace = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_shared_types_1 = __webpack_require__(5790);
const zod_1 = __webpack_require__(5995);
const LLMDynamicHandle_1 = __webpack_require__(6552);
const LLMSpecificModel_1 = __webpack_require__(8546);
const llmLoadModelOptsSchema = zod_1.z.object({
    preset: zod_1.z.string().optional(),
    identifier: zod_1.z.string().optional(),
    config: lms_shared_types_1.llmLoadModelConfigSchema.optional(),
    signal: zod_1.z.instanceof(AbortSignal).optional(),
    verbose: zod_1.z.union([zod_1.z.boolean(), lms_shared_types_1.logLevelSchema]).optional(),
    onProgress: zod_1.z.function().optional(),
    noHup: zod_1.z.boolean().optional(),
});
/** @public */
class LLMNamespace {
    /** @internal */
    constructor(llmPort, validator, parentLogger) {
        this.llmPort = llmPort;
        this.validator = validator;
        this.logger = new lms_common_1.SimpleLogger("Llm", parentLogger);
    }
    /**
     * Load a model for inferencing. The first parameter is the model path. The second parameter is
     * an optional object with additional options. By default, the model is loaded with the default
     * preset (as selected in LM Studio) and the verbose option is set to true.
     *
     * When specifying the model path, you can use the following format:
     *
     * `<publisher>/<repo>[/model_file]`
     *
     * If `model_file` is not specified, the first (sorted alphabetically) model in the repository is
     * loaded.
     *
     * To find out what models are available, you can use the `lms ls` command, or programmatically
     * use the `client.system.listDownloadedModels` method.
     *
     * Here are some examples:
     *
     * Loading Llama 3:
     *
     * ```typescript
     * const model = await client.llm.load("lmstudio-community/Meta-Llama-3-8B-Instruct-GGUF");
     * ```
     *
     * Loading a specific quantization (q4_k_m) of Llama 3:
     *
     * ```typescript
     * const model = await client.llm.load("lmstudio-community/Meta-Llama-3-8B-Instruct-GGUF/Meta-Llama-3-8B-Instruct-Q4_K_M.gguf");
     * ```
     *
     * To unload the model, you can use the `client.llm.unload` method. Additionally, when the last
     * client with the same `clientIdentifier` disconnects, all models loaded by that client will be
     * automatically unloaded.
     *
     * Once loaded, see {@link LLMDynamicHandle} for how to use the model for inferencing or other things you
     * can do with the model.
     *
     * @param path - The path of the model to load. See {@link LLMLoadModelOpts} for
     * details.
     * @param opts - Options for loading the model. See {@link LLMLoadModelOpts} for details.
     * @returns A promise that resolves to the model that can be used for inferencing
     */
    async load(path, opts = {}) {
        const stack = (0, lms_common_1.getCurrentStack)(1);
        [path, opts] = this.validator.validateMethodParamsOrThrow("client.llm", "load", ["path", "opts"], [lms_shared_types_1.reasonableKeyStringSchema, llmLoadModelOptsSchema], [path, opts], stack);
        const { preset, identifier, signal, verbose = "info", config, onProgress, noHup } = opts;
        let lastVerboseCallTime = 0;
        const { promise, resolve, reject } = (0, lms_common_1.makePromise)();
        const verboseLevel = typeof verbose === "boolean" ? "info" : verbose;
        const startTime = Date.now();
        if (verbose) {
            this.logger.logAtLevel(verboseLevel, (0, lms_common_1.text) `
          Verbose logging is enabled. To hide progress logs, set the "verbose" option to false in
          client.llm.load.
        `);
        }
        const channel = this.llmPort.createChannel("loadModel", {
            path,
            identifier,
            preset,
            config: config ?? {},
            noHup: noHup ?? false,
        }, message => {
            switch (message.type) {
                case "success": {
                    if (verbose) {
                        this.logger.logAtLevel(verboseLevel, (0, lms_common_1.text) `
                  Successfully loaded model ${path} in ${Date.now() - startTime}ms
                `);
                    }
                    resolve(new LLMDynamicHandle_1.LLMDynamicHandle(this.llmPort, { type: "sessionIdentifier", sessionIdentifier: message.sessionIdentifier }, this.validator, this.logger));
                    break;
                }
                case "progress": {
                    const { progress } = message;
                    if (onProgress !== undefined) {
                        onProgress(progress);
                    }
                    else if (verbose) {
                        const now = Date.now();
                        if (now - lastVerboseCallTime > 500 || progress === 1) {
                            const progressText = (progress * 100).toFixed(1);
                            this.logger.logAtLevel(verboseLevel, `Loading model ${path}, progress: ${progressText}%`);
                            lastVerboseCallTime = now;
                        }
                    }
                }
            }
        }, { stack });
        channel.onError.subscribeOnce(reject);
        signal?.addEventListener("abort", () => {
            channel.send({ type: "cancel" });
            reject(signal.reason);
        });
        return promise;
    }
    /**
     * Unload a model. Once a model is unloaded, it can no longer be used. If you wish to use the
     * model afterwards, you will need to load it with {@link LLMNamespace#loadModel} again.
     *
     * @param identifier - The identifier of the model to unload.
     */
    unload(identifier) {
        const stack = (0, lms_common_1.getCurrentStack)(1);
        this.validator.validateMethodParamOrThrow("client.llm", "unload", "identifier", lms_shared_types_1.reasonableKeyStringSchema, identifier, stack);
        return this.llmPort.callRpc("unloadModel", { identifier }, { stack });
    }
    /**
     * List all the currently loaded models.
     */
    listLoaded() {
        const stack = (0, lms_common_1.getCurrentStack)(1);
        return this.llmPort.callRpc("listLoaded", undefined, { stack });
    }
    async get(param) {
        const stack = (0, lms_common_1.getCurrentStack)(1);
        this.validator.validateMethodParamOrThrow("client.llm", "get", "param", zod_1.z.union([lms_shared_types_1.reasonableKeyStringSchema, lms_shared_types_1.llmModelQuerySchema]), param, stack);
        let query;
        if (typeof param === "string") {
            query = {
                identifier: param,
            };
        }
        else {
            query = param;
        }
        const info = await this.llmPort.callRpc("getModelInfo", {
            specifier: {
                type: "query",
                query,
            },
            throwIfNotFound: true,
        }, { stack });
        if (info === undefined) {
            throw new Error("Backend should have thrown.");
        }
        return new LLMSpecificModel_1.LLMSpecificModel(this.llmPort, info.sessionIdentifier, info.descriptor, this.validator, new lms_common_1.SimpleLogger("LLMSpecificModel", this.logger));
    }
    createDynamicHandle(param) {
        const stack = (0, lms_common_1.getCurrentStack)(1);
        this.validator.validateMethodParamOrThrow("client.llm", "createDynamicHandle", "param", zod_1.z.union([lms_shared_types_1.reasonableKeyStringSchema, lms_shared_types_1.llmModelQuerySchema]), param, stack);
        let query;
        if (typeof param === "string") {
            query = {
                identifier: param,
            };
        }
        else {
            query = param;
        }
        if (query.path?.includes("\\")) {
            throw (0, lms_common_1.makePrettyError)((0, lms_common_1.text) `
          Model path should not contain backslashes, even if you are on Windows. Use forward
          slashes instead.
        `, stack);
        }
        return new LLMDynamicHandle_1.LLMDynamicHandle(this.llmPort, {
            type: "query",
            query,
        }, this.validator, new lms_common_1.SimpleLogger("DynamicHandle", this.logger));
    }
}
exports.LLMNamespace = LLMNamespace;
//

/***/ }),

/***/ 8546:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LLMSpecificModel = void 0;
const lms_common_1 = __webpack_require__(2934);
const LLMDynamicHandle_1 = __webpack_require__(6552);
/**
 * Represents a specific loaded model. Most LLM related operations are inherited from
 * {@link LLMDynamicHandle}.
 *
 * @public
 */
class LLMSpecificModel extends LLMDynamicHandle_1.LLMDynamicHandle {
    /** @internal */
    constructor(llmPort, sessionIdentifier, descriptor, validator, logger = new lms_common_1.SimpleLogger(`LLMSpecificModel`)) {
        const specifier = {
            type: "sessionIdentifier",
            sessionIdentifier,
        };
        super(llmPort, specifier, validator, logger);
        this.identifier = descriptor.identifier;
        this.path = descriptor.path;
    }
}
exports.LLMSpecificModel = LLMSpecificModel;
//

/***/ }),

/***/ 864:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OngoingPrediction = void 0;
const lms_common_1 = __webpack_require__(2934);
const PredictionResult_1 = __webpack_require__(1858);
/**
 * Represents an ongoing prediction.
 *
 * Note, this class is Promise-like, meaning you can use it as a promise. It resolves to a
 * {@link PredictionResult}, which contains the generated text in the `.content` property. Example
 * usage:
 *
 * ```typescript
 * const result = await model.complete("When will The Winds of Winter be released?");
 * console.log(result.content);
 * ```
 *
 * Or you can use instances methods like `then` and `catch` to handle the result or error of the
 * prediction.
 *
 * ```typescript
 * model.complete("When will The Winds of Winter be released?")
 *  .then(result =\> console.log(result.content))
 *  .catch(error =\> console.error(error));
 * ```
 *
 * Alternatively, you can also stream the result (process the results as more content is being
 * generated). For example:
 *
 * ```typescript
 * for await (const fragment of model.complete("When will The Winds of Winter be released?")) {
 *   process.stdout.write(fragment);
 * }
 * ```
 *
 * @public
 */
class OngoingPrediction extends lms_common_1.StreamablePromise {
    async collect(fragments) {
        if (this.stats === null) {
            throw new Error("Stats should not be null");
        }
        if (this.modelInfo === null) {
            throw new Error("Model info should not be null");
        }
        return new PredictionResult_1.PredictionResult(fragments.join(""), this.stats, this.modelInfo);
    }
    constructor(onCancel) {
        super();
        this.onCancel = onCancel;
        this.stats = null;
        this.modelInfo = null;
    }
    /** @internal */
    static create(onCancel) {
        const ongoingPrediction = new OngoingPrediction(onCancel);
        const finished = (stats, modelInfo) => {
            ongoingPrediction.stats = stats;
            ongoingPrediction.modelInfo = modelInfo;
            ongoingPrediction.finished();
        };
        const failed = (error) => ongoingPrediction.finished(error);
        const push = (fragment) => ongoingPrediction.push(fragment);
        return { ongoingPrediction, finished, failed, push };
    }
    /**
     * Get the final prediction results. If you have been streaming the results, awaiting on this
     * method will take no extra effort, as the results are already available in the internal buffer.
     *
     * Example:
     *
     * ```typescript
     * const prediction = model.complete("When will The Winds of Winter be released?");
     * for await (const fragment of prediction) {
     *   process.stdout.write(fragment);
     * }
     * const result = await prediction.result();
     * console.log(result.stats);
     * ```
     *
     * Technically, awaiting on this method is the same as awaiting on the instance itself:
     *
     * ```typescript
     * await prediction.result();
     *
     * // Is the same as:
     *
     * await prediction;
     * ```
     */
    async result() {
        return await this;
    }
    /**
     * Cancels the prediction. This will stop the prediction with stop reason `userStopped`. See
     * {@link LLMPredictionStopReason} for other reasons that a prediction might stop.
     */
    async cancel() {
        this.onCancel();
    }
}
exports.OngoingPrediction = OngoingPrediction;
//

/***/ }),

/***/ 1858:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PredictionResult = void 0;
/**
 * Represents the result of a prediction.
 *
 * The most notably property is {@link PredictionResult#content}, which contains the generated text.
 * Additionally, the {@link PredictionResult#stats} property contains statistics about the
 * prediction.
 *
 * @public
 */
class PredictionResult {
    constructor(
    /**
     * The newly generated text as predicted by the LLM.
     */
    content, 
    /**
     * Statistics about the prediction.
     */
    stats, 
    /**
     * Information about the model used for the prediction.
     */
    modelInfo) {
        this.content = content;
        this.stats = stats;
        this.modelInfo = modelInfo;
    }
}
exports.PredictionResult = PredictionResult;
//

/***/ }),

/***/ 4600:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemNamespace = void 0;
const lms_common_1 = __webpack_require__(2934);
/** @public */
class SystemNamespace {
    /** @internal */
    constructor(systemPort, parentLogger) {
        this.systemPort = systemPort;
        this.logger = new lms_common_1.SimpleLogger("System", parentLogger);
    }
    /**
     * List all downloaded models.
     * @public
     */
    async listDownloadedModels() {
        return this.systemPort.callRpc("listDownloadedModels", undefined, {
            stack: (0, lms_common_1.getCurrentStack)(1),
        });
    }
}
exports.SystemNamespace = SystemNamespace;
//

/***/ }),

/***/ 4347:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BufferedEvent = void 0;
const Subscribable_1 = __webpack_require__(5293);
const waitForNextMicroTask = Symbol();
/**
 * A buffered event will buffer events in a queue if no subscribers are present. When a subscriber
 * is added, all buffered events will trigger sequentially in the next microtask.
 *
 * Similar to Event, events are always emitted during the next microtask.
 *
 * Attempting to add more than one subscriber will resulting in an error.
 */
class BufferedEvent extends Subscribable_1.Subscribable {
    static create() {
        const event = new BufferedEvent();
        const emitter = data => {
            event.emit(data);
        };
        return [event, emitter];
    }
    constructor() {
        super();
        this.subscriber = null;
        this.queued = [];
        this.isNotifying = false;
    }
    emit(data) {
        if (this.queued.length === 0 && this.queued.at(-1) !== waitForNextMicroTask) {
            this.queued.push(waitForNextMicroTask);
        }
        this.queued.push(data);
        if (!this.isNotifying) {
            this.notifier();
        }
    }
    async notifier() {
        this.isNotifying = true;
        while (this.subscriber !== null && this.queued.length > 0) {
            const data = this.queued.shift();
            if (data === waitForNextMicroTask) {
                await Promise.resolve();
            }
            else {
                this.subscriber(data);
            }
        }
        this.isNotifying = false;
    }
    subscribe(listener) {
        if (this.subscriber !== null) {
            throw new Error("Cannot have more than one subscriber");
        }
        this.subscriber = listener;
        if (!this.isNotifying && this.queued.length > 0) {
            this.queued = [
                waitForNextMicroTask,
                ...this.queued.filter(data => data !== waitForNextMicroTask),
            ];
            this.notifier();
        }
        return () => {
            this.subscriber = null;
        };
    }
}
exports.BufferedEvent = BufferedEvent;
//

/***/ }),

/***/ 2926:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Event = void 0;
const Subscribable_1 = __webpack_require__(5293);
/**
 * Represents an event that can be subscribed to. Emitted events will trigger all subscribers in the
 * next microtask. If multiple events are emitted, they will be triggered in the same microtask.
 */
class Event extends Subscribable_1.Subscribable {
    constructor() {
        super();
        this.subscribers = new Set();
    }
    emit(data) {
        queueMicrotask(() => {
            for (const subscriber of this.subscribers) {
                subscriber(data);
            }
        });
    }
    static create() {
        const event = new Event();
        const emitter = data => {
            event.emit(data);
        };
        return [event, emitter];
    }
    subscribe(listener) {
        this.subscribers.add(listener);
        return () => {
            this.subscribers.delete(listener);
        };
    }
}
exports.Event = Event;
//

/***/ }),

/***/ 1322:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LazySignal = void 0;
const Signal_1 = __webpack_require__(9484);
const Subscribable_1 = __webpack_require__(5293);
const makePromise_1 = __webpack_require__(1245);
/**
 * A lazy signal is a signal that will only subscribe to the upstream when at least one subscriber
 * is attached. It will unsubscribe from the upstream when the last subscriber is removed.
 *
 * A lazy signal can possess a special value "NOT_AVAILABLE", accessible from the static property
 * {@link LazySignal.NOT_AVAILABLE}. This value is used to indicate that the value is not available
 * yet. This can happen when the signal is created without an initial value and the upstream has not
 * emitted a value yet.
 */
class LazySignal extends Subscribable_1.Subscribable {
    static create(initialValue, upstreamSubscriber, equalsPredicate = (a, b) => a === b) {
        return new LazySignal(initialValue, upstreamSubscriber, equalsPredicate);
    }
    static createWithoutInitialValue(upstreamSubscriber, equalsPredicate = (a, b) => a === b) {
        const fullEqualsPredicate = (a, b) => {
            if (a === LazySignal.NOT_AVAILABLE || b === LazySignal.NOT_AVAILABLE) {
                return a === b;
            }
            return equalsPredicate(a, b);
        };
        return new LazySignal(LazySignal.NOT_AVAILABLE, upstreamSubscriber, fullEqualsPredicate);
    }
    constructor(initialValue, upstreamSubscriber, equalsPredicate = (a, b) => a === b) {
        super();
        this.upstreamSubscriber = upstreamSubscriber;
        this.dataIsStale = true;
        this.upstreamUnsubscribe = null;
        this.subscribersCount = 0;
        [this.signal, this.setValue] = Signal_1.Signal.create(initialValue, equalsPredicate);
    }
    /**
     * Returns whether the value is currently stale.
     *
     * A value is stale whenever the upstream subscription is not active. This can happen in two
     * cases:
     *
     * 1. When no subscriber is attached to this signal, the signal will not subscribe to the
     *    upstream. In this case, the value is always stale.
     * 2. When a subscriber is attached, but the upstream has not yet emitted a single value, the
     *    value is also stale.
     *
     * If you wish to get the current value and esnure that it is not stale, use the method
     * {@link LazySignal#pull}.
     */
    isStale() {
        return this.dataIsStale;
    }
    subscribeToUpstream() {
        this.upstreamUnsubscribe = this.upstreamSubscriber(data => {
            this.dataIsStale = false;
            this.setValue(data);
        });
    }
    unsubscribeFromUpstream() {
        if (this.upstreamUnsubscribe !== null) {
            this.upstreamUnsubscribe();
            this.upstreamUnsubscribe = null;
            this.dataIsStale = true;
        }
    }
    /**
     * Gets the current value of the signal. If the value is not available, it will return
     * {@link LazySignal.NOT_AVAILABLE}. In addition, the value returned by this method may be stale.
     * Use {@link LazySignal#isStale} to check if the value is stale.
     *
     * If you wish to get the current value and ensure that it is not stale, use the method
     * {@link LazySignal#pull}.
     */
    get() {
        return this.signal.get();
    }
    /**
     * Pulls the current value of the signal. If the value is stale, it will wait for the next value
     * from the upstream and return it.
     */
    async pull() {
        const { promise, resolve } = (0, makePromise_1.makePromise)();
        if (!this.isStale()) {
            // If not stale, definitely not "NOT_AVAILABLE"
            resolve(this.get());
        }
        this.subscribeOnce(data => {
            resolve(data);
        });
        return promise;
    }
    subscribe(callback) {
        if (this.subscribersCount === 0) {
            this.subscribeToUpstream();
        }
        this.subscribersCount++;
        const unsubscribe = this.signal.subscribe(callback);
        let unsubscribeCalled = false;
        return () => {
            if (unsubscribeCalled) {
                return;
            }
            unsubscribe();
            unsubscribeCalled = true;
            this.subscribersCount--;
            if (this.subscribersCount === 0) {
                this.unsubscribeFromUpstream();
            }
        };
    }
}
exports.LazySignal = LazySignal;
LazySignal.NOT_AVAILABLE = Symbol("notAvailable");
//

/***/ }),

/***/ 9484:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Signal = void 0;
const immer_1 = __webpack_require__(2812);
const Subscribable_1 = __webpack_require__(5293);
const notQueued = Symbol("notQueued");
const equals = (a, b) => a === b;
/**
 * A signal is a wrapper for a value. It can be used to notify subscribers when the value changes.
 * For it to work properly, the value should be immutable.
 *
 * To create a signal, please use the `Signal.create` static method. It will return a signal
 * along with a function to update its value.
 */
class Signal extends Subscribable_1.Subscribable {
    /**
     * Creates a signal.
     *
     * @param value - The initial value of the signal.
     * @param equalsPredicate - A function to compare two values. The subscribers will only be called
     * if the value changes according to the `equalsPredicate`. By default, it uses the `===`
     * operator.
     * @returns This method returns a tuple with two elements:
     * - The signal
     * - A function to update the value
     **/
    static create(value, equalsPredicate = equals) {
        const signal = new Signal(value, equalsPredicate);
        const setValue = (value) => {
            signal.set(value, [
                {
                    op: "replace",
                    path: [],
                    value,
                },
            ]);
        };
        setValue.withImmer = signal.setWithImmer.bind(signal);
        return [signal, setValue];
    }
    constructor(value, equalsPredicate) {
        super();
        this.value = value;
        this.equalsPredicate = equalsPredicate;
        this.subscribers = new Set();
        this.queuedUpdate = notQueued;
        this.queuedPatches = [];
        this.isEmitting = false;
    }
    /**
     * Returns the current value of the signal.
     */
    get() {
        return this.value;
    }
    notify(value) {
        for (const subscriber of this.subscribers) {
            subscriber(value);
        }
    }
    notifyAndUpdateIfChanged(value) {
        if (!this.equalsPredicate(this.value, value)) {
            this.value = value;
            this.notify(value);
        }
    }
    makeReplaceRootPatch(value) {
        return {
            op: "replace",
            path: [],
            value,
        };
    }
    set(value, patches) {
        if (this.isEmitting) {
            // It is already emitting, so we should queue the update.
            this.queuedUpdate = value;
            if (patches === undefined) {
                this.queuedPatches = [this.makeReplaceRootPatch(value)];
            }
            else {
                this.queuedPatches.push(...patches);
            }
            return;
        }
        this.isEmitting = true;
        try {
            this.notifyAndUpdateIfChanged(value);
            while (this.queuedUpdate !== notQueued) {
                const queuedValue = this.queuedUpdate;
                this.queuedUpdate = notQueued;
                this.notifyAndUpdateIfChanged(queuedValue);
            }
        }
        finally {
            this.isEmitting = false;
        }
    }
    setWithImmer(producer) {
        const [updated, patch] = (0, immer_1.produceWithPatches)(this.value, producer);
        this.set(updated, patch);
    }
    /**
     * Subscribes to the signal. The callback will be called whenever the value changes. All callbacks
     * are called synchronously upon updating. It will NOT be immediately called with the current
     * value. (Use `get()` to get the current value.) Returns a function to unsubscribe.
     *
     * Edge cases involving manipulating the signal in the callback:
     *
     * - If the callback adds new subscribers, they will also be called within the same update.
     * - If the callback causes removal of subscribers that have not been called yet, they will no
     *   longer be called.
     * - If the callback causes an update of the value, the update will be queued. If multiple updates
     *   are queued, only the last one will be executed.
     *
     * Edge cases involving adding the same callback multiple times.
     *
     *  - Callbacks are tracked with a set. Adding the same subscriber will not cause it to be called
     *    multiple times.
     */
    subscribe(callback) {
        this.subscribers.add(callback);
        return () => {
            this.subscribers.delete(callback);
        };
    }
}
exports.Signal = Signal;
//

/***/ }),

/***/ 5449:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleLogger = void 0;
const chalk_1 = __importDefault(__webpack_require__(8033));
const text_1 = __webpack_require__(7087);
function isSimpleLogger(logger) {
    return logger?.isSimpleLogger === true;
}
const defaultInfoPrefix = chalk_1.default.greenBright("I");
const defaultWarnPrefix = chalk_1.default.yellowBright("W");
const defaultErrorPrefix = chalk_1.default.redBright("E");
const defaultDebugPrefix = chalk_1.default.blueBright("D");
class SimpleLogger {
    constructor(prefixText = "", parentLogger = console, { useLogLevelPrefixes = true } = {}) {
        this.isSimpleLogger = true;
        this.infoPrefix = [];
        this.warnPrefix = [];
        this.errorPrefix = [];
        this.debugPrefix = [];
        if (isSimpleLogger(parentLogger)) {
            if (prefixText === "") {
                this.innerPrefix = parentLogger.innerPrefix;
                this.fullPrefix = parentLogger.fullPrefix;
            }
            else {
                if (parentLogger.fullPrefix === "") {
                    this.innerPrefix = prefixText;
                }
                else {
                    this.innerPrefix = `${parentLogger.innerPrefix}][${prefixText}`;
                }
                this.fullPrefix = chalk_1.default.whiteBright(`[${this.innerPrefix}]`);
            }
            this.parentLogger = parentLogger.parentLogger;
        }
        else {
            if (prefixText === "") {
                this.innerPrefix = "";
                this.fullPrefix = "";
            }
            else {
                this.innerPrefix = prefixText;
                this.fullPrefix = chalk_1.default.whiteBright(`[${this.innerPrefix}]`);
            }
            this.parentLogger = parentLogger;
        }
        if (useLogLevelPrefixes) {
            this.infoPrefix.push(defaultInfoPrefix);
            this.warnPrefix.push(defaultWarnPrefix);
            this.errorPrefix.push(defaultErrorPrefix);
            this.debugPrefix.push(defaultDebugPrefix);
        }
        if (this.fullPrefix !== "") {
            this.infoPrefix.push(this.fullPrefix);
            this.warnPrefix.push(this.fullPrefix);
            this.errorPrefix.push(this.fullPrefix);
            this.debugPrefix.push(this.fullPrefix);
        }
    }
    subclass(prefixText) {
        return new SimpleLogger(`${this.innerPrefix}:${prefixText}`, this.parentLogger);
    }
    info(...messages) {
        this.parentLogger.info(...this.infoPrefix, ...messages);
    }
    infoText(strings, ...values) {
        this.info((0, text_1.text)(strings, ...values));
    }
    infoWithoutPrefix(...messages) {
        this.parentLogger.info(...messages);
    }
    error(...messages) {
        this.parentLogger.error(...this.errorPrefix, ...messages);
    }
    errorText(strings, ...values) {
        this.error((0, text_1.text)(strings, ...values));
    }
    errorWithoutPrefix(...messages) {
        this.parentLogger.error(...messages);
    }
    warn(...messages) {
        this.parentLogger.warn(...this.warnPrefix, ...messages);
    }
    warnText(strings, ...values) {
        this.warn((0, text_1.text)(strings, ...values));
    }
    warnWithoutPrefix(...messages) {
        this.parentLogger.warn(...messages);
    }
    debug(...messages) {
        this.parentLogger.debug(...this.debugPrefix, ...messages);
    }
    debugText(strings, ...values) {
        this.debug((0, text_1.text)(strings, ...values));
    }
    debugWithoutPrefix(...messages) {
        this.parentLogger.debug(...messages);
    }
    throw(message) {
        throw new Error(`${this.fullPrefix} ${message}`);
    }
    logAtLevel(level, ...messages) {
        switch (level) {
            case "debug":
                this.debug(...messages);
                break;
            case "info":
                this.info(...messages);
                break;
            case "warn":
                this.warn(...messages);
                break;
            case "error":
                this.error(...messages);
                break;
        }
    }
}
exports.SimpleLogger = SimpleLogger;
//

/***/ }),

/***/ 3935:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StreamablePromise = void 0;
const makePromise_1 = __webpack_require__(1245);
const finished = Symbol("finished");
/**
 * A StreamablePromise is a promise-like that is also async iterable. This means you can use it as a
 * promise (awaiting it, using `.then`, `.catch`, etc.), and you can also use it as an async
 * iterable (using `for await`).
 *
 * Notably, as much as it implements the async iterable interface, it is not a traditional iterable,
 * as it internally maintains a buffer and new values are pushed into the buffer by the producer, as
 * oppose to being pulled by the consumer.
 *
 * The async iterable interface is used instead of the Node.js object stream because streams are too
 * clunky to use, and the `for await` syntax is much more ergonomic for most people.
 *
 * If any iterator is created for this instance, an empty rejection handler will be attached to the
 * promise to prevent unhandled rejection warnings.
 *
 * This class is provided as an abstract class and is meant to be extended. Crucially, the `collect`
 * method must be implemented, which will be called to convert an array of values into the final
 * resolved value of the promise.
 *
 * In addition, the constructor of the subclass should be marked as private, and a static method
 * that exposes the constructor, the `finished` method, and the `push` method should be provided.
 *
 * @typeParam TFragment - The type of the individual fragments that are pushed into the buffer.
 * @typeParam TFinal - The type of the final resolved value of the promise.
 * @public
 */
class StreamablePromise {
    /**
     * Called by the producer when it has finished producing values. If an error is provided, the
     * promise will be rejected with that error. If no error is provided, the promise will be resolved
     * with the final value.
     *
     * This method should be exposed in the static constructor of the subclass.
     *
     * @param error - The error to reject the promise with, if any.
     */
    finished(error) {
        if (this.status !== "pending") {
            throw new Error("`finished` called while not pending");
        }
        if (error === undefined) {
            this.status = "resolved";
            this.nextFragmentPromiseBundle?.resolve(finished);
            this.resolveFinal(this.collect(this.buffer));
        }
        else {
            this.status = "rejected";
            this.nextFragmentPromiseBundle?.reject(error);
            this.rejectFinal(error);
        }
    }
    /**
     * Called by the producer to push a new fragment into the buffer. This method should be exposed in
     * the static constructor of the subclass.
     *
     * This method should be exposed in the static constructor of the subclass.
     *
     * @param fragment - The fragment to push into the buffer.
     */
    push(fragment) {
        if (this.status !== "pending") {
            throw new Error("`push` called while not pending");
        }
        this.buffer.push(fragment);
        this.nextFragmentPromiseBundle?.resolve(fragment);
        this.nextFragmentPromiseBundle = null;
    }
    constructor() {
        this.status = "pending";
        this.buffer = [];
        this.nextFragmentPromiseBundle = null;
        /**
         * If there has ever been any iterators created for this instance. Once any iterator is created,
         * a reject handler will be attached to the promise to prevent unhandled rejection warnings, as
         * the errors will be handled by the iterator.
         *
         * The purpose of this variable is to prevent registering the reject handler more than once.
         */
        this.hasIterator = false;
        this[_a] = "StreamablePromise";
        const { promise, resolve, reject } = (0, makePromise_1.makePromise)();
        this.promiseFinal = promise;
        this.resolveFinal = resolve;
        this.rejectFinal = reject;
    }
    then(onfulfilled, onrejected) {
        return this.promiseFinal.then(onfulfilled, onrejected);
    }
    catch(onrejected) {
        return this.promiseFinal.catch(onrejected);
    }
    finally(onfinally) {
        return this.promiseFinal.finally(onfinally);
    }
    /**
     * If nextFragmentPromiseBundle exists, it is returned. Otherwise, a new one is created and
     * returned.
     */
    obtainNextFragmentPromiseBundle() {
        if (this.nextFragmentPromiseBundle === null) {
            this.nextFragmentPromiseBundle = (0, makePromise_1.makePromise)();
        }
        return this.nextFragmentPromiseBundle;
    }
    async *[(_a = Symbol.toStringTag, Symbol.asyncIterator)]() {
        if (!this.hasIterator) {
            this.promiseFinal.catch(() => { }); // Prevent unhandled rejection warning
            this.hasIterator = true;
        }
        let i = 0;
        while (this.status === "pending") {
            if (i < this.buffer.length) {
                yield this.buffer[i];
                i++;
            }
            else {
                const nextFragmentPromiseBundle = this.obtainNextFragmentPromiseBundle();
                const nextFragment = await nextFragmentPromiseBundle.promise;
                if (nextFragment === finished) {
                    break;
                }
                yield nextFragment;
                i++;
            }
        }
    }
}
exports.StreamablePromise = StreamablePromise;
//

/***/ }),

/***/ 5293:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Subscribable = void 0;
const LazySignal_1 = __webpack_require__(1322);
/**
 * Base class for objects that can be subscribed to. Provides common utility methods.
 */
class Subscribable {
    subscribeOnce(listener) {
        const unsubscribe = this.subscribe(data => {
            unsubscribe();
            listener(data);
        });
        return unsubscribe;
    }
    deriveLazySignal(deriver, outputEqualsPredicate = (a, b) => a === b) {
        const thisWithGetter = this;
        if (thisWithGetter.get !== undefined) {
            return LazySignal_1.LazySignal.create(deriver(thisWithGetter.get()), listener => {
                return this.subscribe(data => {
                    listener(deriver(data));
                });
            }, outputEqualsPredicate);
        }
        return LazySignal_1.LazySignal.createWithoutInitialValue(listener => {
            return this.subscribe(data => {
                listener(deriver(data));
            });
        }, outputEqualsPredicate);
    }
}
exports.Subscribable = Subscribable;
//

/***/ }),

/***/ 4013:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutTracker = void 0;
const BufferedEvent_1 = __webpack_require__(4347);
class TimeoutTracker {
    constructor(timeoutMs) {
        this.timeoutMs = timeoutMs;
        this.started = false;
        this.timeout = null;
        [this.triggeredEvent, this.emitTriggeredEvent] = BufferedEvent_1.BufferedEvent.create();
    }
    reset() {
        if (!this.started) {
            return;
        }
        if (this.timeout !== null) {
            clearTimeout(this.timeout);
        }
        this.timeout = setTimeout(() => {
            this.emitTriggeredEvent();
            if (this.timeout !== null) {
                clearTimeout(this.timeout);
            }
        }, this.timeoutMs);
    }
    start() {
        this.started = true;
        this.reset();
    }
    stop() {
        if (this.timeout !== null) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
        this.started = false;
    }
}
exports.TimeoutTracker = TimeoutTracker;
//

/***/ }),

/***/ 3496:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Validator = void 0;
const chalk_1 = __importDefault(__webpack_require__(8033));
const makePrettyError_1 = __webpack_require__(7578);
const text_1 = __webpack_require__(7087);
class Validator {
    constructor({ attachStack } = {}) {
        this.attachStack = attachStack ?? true;
    }
    /**
     * Pretty-prints a Zod error.
     *
     * @param rootObjectName - The name of the object being validated (used for error messages)
     * @param error - The Zod error to pretty-print
     *
     * @returns The pretty-printed error in a string
     */
    static prettyPrintZod(rootObjectName, error) {
        return error.errors
            .map(e => {
            if (e.path.length === 0) {
                return `- ${chalk_1.default.redBright(rootObjectName)}: ${e.message}`;
            }
            const path = chalk_1.default.red(`.${e.path.join(".")}`);
            return `- ${chalk_1.default.redBright(rootObjectName)}${path}: ${e.message}`;
        })
            .join("\n");
    }
    /**
     * Validates a value against a schema and throws an error if it's invalid.
     *
     * @param lead - The start of the error message (used for error messages)
     * @param rootObjectName - The name of the object being validated (used for error messages)
     * @param schema - The schema to validate against
     * @param value - The value to validate
     *
     * @returns The validated value
     * @throws An error if the value is invalid
     */
    validateOrThrow(lead, rootObjectName, schema, value, stack) {
        const result = schema.safeParse(value);
        if (result.success) {
            return result.data;
        }
        else {
            throw (0, makePrettyError_1.makePrettyError)(`${lead}\n\n${Validator.prettyPrintZod(rootObjectName, result.error)}`, this.attachStack ? stack : undefined);
        }
    }
    /**
     * Validates multiple values against multiple schemas and throws an error if any of them are
     * invalid. All values are validated before any errors are thrown. This is useful when you want to
     * validate multiple values at once and want to see all the errors at once.
     *
     * @param leadProducer - The function to produce the start of the error message (used for error).
     * It is called with a set of indices of the invalid values.
     * @param rootObjectNames - The names of the objects being validated (used for error messages)
     * @param schemas - The schemas to validate against
     * @param values - The values to validate
     *
     * @returns The validated values
     * @throws An error if any of the values are invalid
     */
    validateMultipleOrThrow(leadProducer, rootObjectNames, schemas, values, stack) {
        const results = schemas.map((schema, index) => schema.safeParse(values[index]));
        const errors = results
            .map((result, index) => ({ result, index, rootObjectName: rootObjectNames[index] }))
            .filter(({ result }) => !result.success)
            .map(({ result, rootObjectName, index }) => ({
            error: result.error,
            rootObjectName,
            index,
        }));
        if (errors.length === 0) {
            return values;
        }
        else {
            const erroredValues = new Set(errors.map(({ index }) => index));
            const lead = leadProducer(erroredValues);
            throw (0, makePrettyError_1.makePrettyError)(`${lead}\n\n${errors
                .map(({ error, rootObjectName }) => Validator.prettyPrintZod(rootObjectName, error))
                .join("\n")}`, this.attachStack ? stack : undefined);
        }
    }
    /**
     * Validates a value against a schema and throws an error if it's invalid. This is a convenience
     * function for validating one single method parameter.
     *
     * @param className - The name of the class containing the method (used for error messages)
     * @param methodName - The name of the method (used for error messages)
     * @param paramName - The name of the parameter being validated (used for error messages)
     * @param schema - The schema to validate against
     * @param value - The value to validate
     *
     * @returns The validated value
     * @throws An error if the value is invalid
     */
    validateMethodParamOrThrow(className, methodName, paramName, schema, value, stack) {
        const functionCall = chalk_1.default.yellowBright((0, text_1.text) `
    ${className}.${methodName}(${chalk_1.default.redBright(paramName)})
  `);
        return this.validateOrThrow(`Invalid parameter(s) for ${functionCall}:`, paramName, schema, value, stack);
    }
    /**
     * Validates multiple values against multiple schemas and throws an error if any of them are
     * invalid. This is a convenience function for validating multiple method parameters.
     *
     * @param className - The name of the class containing the method (used for error messages)
     * @param methodName - The name of the method (used for error messages)
     * @param paramNames - The names of the parameters being validated (used for error messages)
     * @param schemas - The schemas to validate against
     * @param values - The values to validate
     *
     * @returns The validated values
     * @throws An error if any of the values are invalid
     */
    validateMethodParamsOrThrow(className, methodName, paramNames, schemas, values, stack) {
        return this.validateMultipleOrThrow(erroredValues => {
            const coloredParamNames = paramNames.map((name, index) => erroredValues.has(index) ? chalk_1.default.redBright(name) : name);
            const functionCall = chalk_1.default.yellowBright((0, text_1.text) `
        ${className}.${methodName}(${coloredParamNames.join(", ")})
      `);
            return `Invalid parameter(s) for ${functionCall}:`;
        }, paramNames, schemas, values, stack);
    }
    /**
     * Validates a value against a schema and throws an error if it's invalid. This is a convenience
     * function for validating one single constructor parameter.
     *
     * @param className - The name of the class (used for error messages)
     * @param paramName - The name of the parameter being validated (used for error messages)
     * @param schema - The schema to validate against
     * @param value - The value to validate
     *
     * @returns The validated value
     * @throws An error if the value is invalid
     */
    validateConstructorParamOrThrow(className, paramName, schema, value, stack) {
        const functionCall = chalk_1.default.yellowBright((0, text_1.text) `
    ${className}(${chalk_1.default.redBright(paramName)})
  `);
        return this.validateOrThrow(`Invalid parameter(s) when constructing ${functionCall}`, paramName, schema, value, stack);
    }
    /**
     * Validates multiple values against multiple schemas and throws an error if any of them are
     * invalid. This is a convenience function for validating multiple constructor parameters.
     *
     * @param className - The name of the class (used for error messages)
     * @param paramNames - The names of the parameters being validated (used for error messages)
     *
     * @param schemas - The schemas to validate against
     * @param values - The values to validate
     */
    validateConstructorParamsOrThrow(className, paramNames, schemas, values, stack) {
        return this.validateMultipleOrThrow(erroredValues => {
            const coloredParamNames = paramNames.map((name, index) => erroredValues.has(index) ? chalk_1.default.redBright(name) : name);
            const functionCall = chalk_1.default.yellowBright((0, text_1.text) `
        ${className}(${coloredParamNames.join(", ")})
      `);
            return `Invalid parameter(s) when constructing ${functionCall}:`;
        }, paramNames, schemas, values, stack);
    }
}
exports.Validator = Validator;
//

/***/ }),

/***/ 8162:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Holder = exports.Pager = exports.WaitQueue = exports.QueueClearedError = exports.PagerExitedError = void 0;
const SimpleLogger_1 = __webpack_require__(5449);
const makePromise_1 = __webpack_require__(1245);
const resolvePager = Symbol("resolvePager");
const rejectPager = Symbol("rejectPager");
const dropHolder = Symbol("dropHolder");
const getLogger = Symbol("logger");
const removePager = Symbol("removePager");
class PagerExitedError extends Error {
    constructor() {
        super("Pager has been exited");
    }
}
exports.PagerExitedError = PagerExitedError;
class QueueClearedError extends Error {
    constructor() {
        super("Queue has been cleared");
    }
}
exports.QueueClearedError = QueueClearedError;
/**
 * WaitQueue is a queue that can be used to wait for a resource to become available.
 *
 * It is similar to going to a busy restaurant in that you get a pager (the plastic thing that has a
 * red LED on it), which will beep when your table is ready.
 *
 * The {@link WaitQueue#enterQueue} method is used to get a pager, and the Pager object that is
 * returned can be waited on using the {@link Pager#wait} method, which returns a promise that
 * resolves to a {@link Holder} object. When you are done, {@link Holder#drop} should be called to
 * release the resource. Alternatively, the `using` keyword can be used to automatically release the
 * resource when the block is exited.
 *
 * Queue can be exited with the {@link Pager#exit} method.
 */
class WaitQueue {
    constructor(parentLogger) {
        this.pagers = [];
        this.finalizationRegistry = new FinalizationRegistry(() => {
            this.logger.warnText `
      A holder has been finalized without being dropped! FinalizationRegistry is the last resort
      and should not be relied upon. Please make sure to always drop the holder when you are done
      with it.
    `;
            this.currentlyServing = null;
            this.tryAdvancingQueue();
        });
        this.currentlyServing = null;
        this.logger = new SimpleLogger_1.SimpleLogger("WaitQueue", parentLogger);
    }
    /**
     * Enters the queue and returns a pager that can be waited on.
     *
     * @param priority - The priority of the pager. Lower numbers are served first. Defaults to 0.
     */
    enterQueue(priority = 0) {
        const pager = new Pager(this, priority);
        this.pagers.push(pager);
        this.pagers.sort((a, b) => (a.priority < b.priority ? -1 : a.priority > b.priority ? 1 : 0));
        this.tryAdvancingQueue();
        return pager;
    }
    tryAdvancingQueue() {
        if (this.currentlyServing === null) {
            const pager = this.pagers.shift();
            if (pager !== undefined) {
                this.currentlyServing = pager;
                const holder = new Holder(this);
                this.finalizationRegistry.register(holder, undefined, holder);
                pager[resolvePager](holder);
            }
        }
    }
    clearQueue(error = new QueueClearedError()) {
        for (const pager of this.pagers) {
            pager[rejectPager](error);
        }
        this.pagers.length = 0;
    }
    /** @internal */
    [dropHolder](holder) {
        this.finalizationRegistry.unregister(holder);
        this.currentlyServing = null;
        this.tryAdvancingQueue();
    }
    /** @internal */
    [getLogger]() {
        return this.logger;
    }
    /** @internal */
    [removePager](pager) {
        const index = this.pagers.indexOf(pager);
        if (index !== -1) {
            this.pagers.splice(index, 1);
        }
        else {
            this.logger.warnText `
        A pager was removed from the queue, but it was not in the queue. This is a bug in the code
        that uses the WaitQueue.
      `;
        }
    }
}
exports.WaitQueue = WaitQueue;
class Pager {
    /** @internal */
    constructor(queue, priority) {
        this.queue = queue;
        this.priority = priority;
        const { promise, resolve, reject } = (0, makePromise_1.makePromise)();
        this.waitingPromise = promise;
        this.resolveWaitingPromise = resolve;
        this.rejectWaitingPromise = reject;
    }
    /** @internal */
    [resolvePager](holder) {
        this.resolveWaitingPromise(holder);
    }
    /** @internal */
    [rejectPager](error) {
        this.rejectWaitingPromise(error);
    }
    wait() {
        return this.waitingPromise;
    }
    exit(error = new PagerExitedError()) {
        this.queue[removePager](this);
        this[rejectPager](error);
    }
}
exports.Pager = Pager;
class Holder {
    /** @internal */
    constructor(queue) {
        this.queue = queue;
        this.dropped = false;
    }
    drop() {
        if (this.dropped) {
            this.queue[getLogger]().throw("Holder has already been dropped. This is a bug in the code that uses the WaitQueue.");
        }
        this.dropped = true;
        this.queue[dropHolder](this);
    }
    [Symbol.dispose]() {
        this.drop();
    }
}
exports.Holder = Holder;
//

/***/ }),

/***/ 2130:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.changeErrorStackInPlace = exports.getCurrentStack = void 0;
const process_1 = __importDefault(__webpack_require__(9771));
// Error stack manipulation related functions
function getCurrentStack(goAbove = 0) {
    const stack = new Error().stack;
    if (!stack) {
        return "";
    }
    const lines = stack.split("\n");
    return lines.slice(2 + goAbove).join("\n");
}
exports.getCurrentStack = getCurrentStack;
function changeErrorStackInPlace(error, newStack) {
    if (process_1.default.env.LMS_KEEP_INTERNAL_STACK) {
        return;
    }
    const stackContent = error.stack ?? "";
    error.stack = (stackContent.substring(0, stackContent.indexOf("\n    at ")).trimEnd() +
        "\n" +
        newStack).trimEnd();
}
exports.changeErrorStackInPlace = changeErrorStackInPlace;
//

/***/ }),

/***/ 2934:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.filteredArray = exports.failOk = exports.WaitQueue = exports.QueueClearedError = exports.PagerExitedError = exports.Validator = exports.toJSONSafeNumber = exports.TimeoutTracker = exports.text = exports.StreamablePromise = exports.SimpleLogger = exports.Signal = exports.runOnDispose = exports.unwrapPromiseOfResult = exports.unwrapPromiseOfMaybeErrored = exports.promiseToResult = exports.promiseToMaybeErrored = exports.maybeErroredSchema = exports.createResultSchema = exports.removeUndefinedValues = exports.makePromise = exports.makeTitledPrettyError = exports.makePrettyError = exports.lmsDefaultPorts = exports.Event = exports.getCurrentStack = exports.changeErrorStackInPlace = exports.BufferedEvent = exports.LazySignal = void 0;
const immer_1 = __webpack_require__(2812);
__webpack_require__(9407);
(0, immer_1.enablePatches)();
// Export lazy signal first to avoid circular dependency issues
var LazySignal_1 = __webpack_require__(1322);
Object.defineProperty(exports, "LazySignal", ({ enumerable: true, get: function () { return LazySignal_1.LazySignal; } }));
var BufferedEvent_1 = __webpack_require__(4347);
Object.defineProperty(exports, "BufferedEvent", ({ enumerable: true, get: function () { return BufferedEvent_1.BufferedEvent; } }));
var errorStack_1 = __webpack_require__(2130);
Object.defineProperty(exports, "changeErrorStackInPlace", ({ enumerable: true, get: function () { return errorStack_1.changeErrorStackInPlace; } }));
Object.defineProperty(exports, "getCurrentStack", ({ enumerable: true, get: function () { return errorStack_1.getCurrentStack; } }));
var Event_1 = __webpack_require__(2926);
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return Event_1.Event; } }));
var lmsDefaultPorts_1 = __webpack_require__(8393);
Object.defineProperty(exports, "lmsDefaultPorts", ({ enumerable: true, get: function () { return lmsDefaultPorts_1.lmsDefaultPorts; } }));
var makePrettyError_1 = __webpack_require__(7578);
Object.defineProperty(exports, "makePrettyError", ({ enumerable: true, get: function () { return makePrettyError_1.makePrettyError; } }));
Object.defineProperty(exports, "makeTitledPrettyError", ({ enumerable: true, get: function () { return makePrettyError_1.makeTitledPrettyError; } }));
var makePromise_1 = __webpack_require__(1245);
Object.defineProperty(exports, "makePromise", ({ enumerable: true, get: function () { return makePromise_1.makePromise; } }));
var removeUndefinedValues_1 = __webpack_require__(5964);
Object.defineProperty(exports, "removeUndefinedValues", ({ enumerable: true, get: function () { return removeUndefinedValues_1.removeUndefinedValues; } }));
var resultTypes_1 = __webpack_require__(1956);
Object.defineProperty(exports, "createResultSchema", ({ enumerable: true, get: function () { return resultTypes_1.createResultSchema; } }));
Object.defineProperty(exports, "maybeErroredSchema", ({ enumerable: true, get: function () { return resultTypes_1.maybeErroredSchema; } }));
Object.defineProperty(exports, "promiseToMaybeErrored", ({ enumerable: true, get: function () { return resultTypes_1.promiseToMaybeErrored; } }));
Object.defineProperty(exports, "promiseToResult", ({ enumerable: true, get: function () { return resultTypes_1.promiseToResult; } }));
Object.defineProperty(exports, "unwrapPromiseOfMaybeErrored", ({ enumerable: true, get: function () { return resultTypes_1.unwrapPromiseOfMaybeErrored; } }));
Object.defineProperty(exports, "unwrapPromiseOfResult", ({ enumerable: true, get: function () { return resultTypes_1.unwrapPromiseOfResult; } }));
var runOnDispose_1 = __webpack_require__(7485);
Object.defineProperty(exports, "runOnDispose", ({ enumerable: true, get: function () { return runOnDispose_1.runOnDispose; } }));
var Signal_1 = __webpack_require__(9484);
Object.defineProperty(exports, "Signal", ({ enumerable: true, get: function () { return Signal_1.Signal; } }));
var SimpleLogger_1 = __webpack_require__(5449);
Object.defineProperty(exports, "SimpleLogger", ({ enumerable: true, get: function () { return SimpleLogger_1.SimpleLogger; } }));
var StreamablePromise_1 = __webpack_require__(3935);
Object.defineProperty(exports, "StreamablePromise", ({ enumerable: true, get: function () { return StreamablePromise_1.StreamablePromise; } }));
var text_1 = __webpack_require__(7087);
Object.defineProperty(exports, "text", ({ enumerable: true, get: function () { return text_1.text; } }));
var TimeoutTracker_1 = __webpack_require__(4013);
Object.defineProperty(exports, "TimeoutTracker", ({ enumerable: true, get: function () { return TimeoutTracker_1.TimeoutTracker; } }));
var toJSONSafeNumber_1 = __webpack_require__(9891);
Object.defineProperty(exports, "toJSONSafeNumber", ({ enumerable: true, get: function () { return toJSONSafeNumber_1.toJSONSafeNumber; } }));
var Validator_1 = __webpack_require__(3496);
Object.defineProperty(exports, "Validator", ({ enumerable: true, get: function () { return Validator_1.Validator; } }));
var WaitQueue_1 = __webpack_require__(8162);
Object.defineProperty(exports, "PagerExitedError", ({ enumerable: true, get: function () { return WaitQueue_1.PagerExitedError; } }));
Object.defineProperty(exports, "QueueClearedError", ({ enumerable: true, get: function () { return WaitQueue_1.QueueClearedError; } }));
Object.defineProperty(exports, "WaitQueue", ({ enumerable: true, get: function () { return WaitQueue_1.WaitQueue; } }));
var zodHelpers_1 = __webpack_require__(9662);
Object.defineProperty(exports, "failOk", ({ enumerable: true, get: function () { return zodHelpers_1.failOk; } }));
Object.defineProperty(exports, "filteredArray", ({ enumerable: true, get: function () { return zodHelpers_1.filteredArray; } }));
//

/***/ }),

/***/ 8393:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lmsDefaultPorts = void 0;
exports.lmsDefaultPorts = [1234];
//

/***/ }),

/***/ 7578:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makePrettyError = exports.makeTitledPrettyError = void 0;
const lms_isomorphic_1 = __webpack_require__(390);
const boxen_1 = __importDefault(__webpack_require__(9204));
const chalk_1 = __importDefault(__webpack_require__(8033));
const process_1 = __importDefault(__webpack_require__(9771));
const errorStack_1 = __webpack_require__(2130);
function makeTitledPrettyError(title, content, stack) {
    return makePrettyError(chalk_1.default.bgRed.white(` ${title} `) + "\n\n" + content, stack);
}
exports.makeTitledPrettyError = makeTitledPrettyError;
function makePrettyError(content, stack) {
    if (process_1.default.browser || process_1.default.env.LMS_NO_FANCY_ERRORS || (0, lms_isomorphic_1.terminalSize)().columns < 80) {
        const error = new Error(content);
        if (stack === undefined) {
            (0, errorStack_1.changeErrorStackInPlace)(error, "");
        }
        else {
            (0, errorStack_1.changeErrorStackInPlace)(error, stack);
        }
        return error;
    }
    else {
        if (stack !== undefined) {
            content +=
                "\n\n\n " + chalk_1.default.bgWhite.black("  </> STACK TRACE  ") + "\n\n" + chalk_1.default.gray(stack);
        }
        const error = new Error("\n" + (0, boxen_1.default)(content, { padding: 1, margin: 1, borderColor: "redBright", title: "Error" }));
        (0, errorStack_1.changeErrorStackInPlace)(error, "");
        return error;
    }
}
exports.makePrettyError = makePrettyError;
//

/***/ }),

/***/ 1245:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makePromise = void 0;
function makePromise() {
    let resolve;
    let reject;
    const promise = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
    });
    return { promise, resolve: resolve, reject: reject };
}
exports.makePromise = makePromise;
//

/***/ }),

/***/ 9407:
/***/ (() => {

"use strict";

// Extremely lightweight polyfill for Symbol.dispose and Symbol.asyncDispose
if (typeof Symbol.dispose !== "symbol") {
    Object.defineProperty(Symbol, "dispose", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Symbol.for("dispose"),
    });
}
if (typeof Symbol.asyncDispose !== "symbol") {
    Object.defineProperty(Symbol, "asyncDispose", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Symbol.for("asyncDispose"),
    });
}
//

/***/ }),

/***/ 5964:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeUndefinedValues = void 0;
/**
 * Removes properties with `undefined` values from an object.
 *
 * This function can be useful in scenarios where you want to ensure that an object does not contain
 * any `undefined` values. For example, when the resulting value is used to overwrite some default
 * values.
 *
 * Note: This function does not mutate the original object. It returns a new object that does not
 * include the `undefined` values.
 *
 * @param obj - The object from which to remove `undefined` values.
 * @returns A new object that does not include the `undefined` values.
 * @example
 * ```typescript
 * const obj = { a: 1, b: undefined, c: 'test' };
 * const result = removeUndefinedValues(obj);
 * console.log(result); // { a: 1, c: 'test' }
 * ```
 */
function removeUndefinedValues(obj) {
    return Object.fromEntries(Object.entries(obj).filter(([_, v]) => v !== undefined));
}
exports.removeUndefinedValues = removeUndefinedValues;
//

/***/ }),

/***/ 1956:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unwrapPromiseOfResult = exports.promiseToResult = exports.createResultSchema = exports.unwrapPromiseOfMaybeErrored = exports.promiseToMaybeErrored = exports.maybeErroredSchema = void 0;
const lms_shared_types_1 = __webpack_require__(5790);
const zod_1 = __webpack_require__(5995);
exports.maybeErroredSchema = zod_1.z.discriminatedUnion("success", [
    zod_1.z.object({
        success: zod_1.z.literal(true),
    }),
    zod_1.z.object({
        success: zod_1.z.literal(false),
        error: lms_shared_types_1.serializedLMSExtendedErrorSchema,
    }),
]);
function promiseToMaybeErrored(promise) {
    return promise.then(() => ({ success: true }), error => ({ success: false, error: (0, lms_shared_types_1.serializeError)(error) }));
}
exports.promiseToMaybeErrored = promiseToMaybeErrored;
async function unwrapPromiseOfMaybeErrored(promise) {
    const result = await promise;
    if (result.success) {
        return Promise.resolve();
    }
    else {
        return Promise.reject((0, lms_shared_types_1.fromSerializedError)(result.error));
    }
}
exports.unwrapPromiseOfMaybeErrored = unwrapPromiseOfMaybeErrored;
function createResultSchema(schema) {
    return zod_1.z.discriminatedUnion("success", [
        zod_1.z.object({
            success: zod_1.z.literal(true),
            result: schema,
        }),
        zod_1.z.object({
            success: zod_1.z.literal(false),
            error: lms_shared_types_1.serializedLMSExtendedErrorSchema,
        }),
    ]);
}
exports.createResultSchema = createResultSchema;
function promiseToResult(promise) {
    return promise.then(result => ({ success: true, result }), error => ({ success: false, error: (0, lms_shared_types_1.serializeError)(error) }));
}
exports.promiseToResult = promiseToResult;
async function unwrapPromiseOfResult(promise) {
    const result = await promise;
    if (result.success) {
        return result.result;
    }
    else {
        return Promise.reject((0, lms_shared_types_1.fromSerializedError)(result.error));
    }
}
exports.unwrapPromiseOfResult = unwrapPromiseOfResult;
//

/***/ }),

/***/ 7485:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runOnDispose = void 0;
function runOnDispose(fn) {
    return {
        [Symbol.dispose]: fn,
    };
}
exports.runOnDispose = runOnDispose;
//

/***/ }),

/***/ 7087:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.text = void 0;
/**
 * A cache for avoiding recompiling the same template strings.
 *
 * The cached value is a string with 2N + 1 elements, where N is the number of variables in the
 * template.
 */
const compiledTemplatesCache = new WeakMap();
/**
 * A string literal tag function that does the following:
 *
 * - Removes leading new lines
 * - Removes trailing new lines and whitespace
 * - Removes common indentation from the start of each line (Empty lines are ignored)
 * - Single newlines are replaced with a space + extra whitespace is removed
 *
 * Note: Only spaces are considered.
 */
function text(strings, ...values) {
    if (values.length + 1 !== strings.length) {
        throw new Error("text called with the wrong number of arguments.");
    }
    let compiled = compiledTemplatesCache.get(strings);
    if (compiled === undefined) {
        compiled = compile(strings);
        compiledTemplatesCache.set(strings, compiled);
    }
    // We can modify the array in place because JavaScript is single-threaded and the array is not
    // being accessed by any other code.
    for (let i = 0; i < values.length; i++) {
        if (typeof values[i] === "object") {
            try {
                compiled[i * 2 + 1] = JSON.stringify(values[i]);
            }
            catch (error) {
                compiled[i * 2 + 1] = "[Object failed to stringify]";
            }
        }
        else {
            compiled[i * 2 + 1] = String(values[i]);
        }
    }
    return compiled.join("");
}
exports.text = text;
function removeLeadingNewlines(input) {
    return input.replace(/^\n+/, "");
}
function removeTrailingNewlinesAndWhitespace(input) {
    return input.replace(/[\n ]+$/, "");
}
function removeLeadingWhitespace(input) {
    return input.replace(/^ +/, "");
}
function removeTrailingWhitespace(input) {
    return input.replace(/ +$/, "");
}
function breakIntoLines(strings) {
    const lines = [];
    let currentLine = [];
    for (const string of strings) {
        let prevNewlineIndex = -1;
        let nextNewlineIndex;
        while ((nextNewlineIndex = string.indexOf("\n", prevNewlineIndex + 1)) !== -1) {
            currentLine.push(string.substring(prevNewlineIndex + 1, nextNewlineIndex));
            lines.push(currentLine);
            currentLine = [];
            prevNewlineIndex = nextNewlineIndex;
        }
        currentLine.push(string.substring(prevNewlineIndex + 1));
    }
    lines.push(currentLine);
    return lines;
}
/**
 * Returns the number of spaces at the start of the string. If the string only contains spaces,
 * returns infinity.
 */
function countStringIndentations(string) {
    let count = 0;
    for (const char of string) {
        if (char === " ") {
            count++;
        }
        else {
            return count;
        }
    }
    return Infinity;
}
function countLineIndentations(line) {
    const firstPart = line[0];
    const firstPartIndentation = countStringIndentations(firstPart);
    if (firstPartIndentation === Infinity) {
        if (line.length === 1) {
            return Infinity;
        }
        else {
            // If there is a variable after it, the length of indentation is the same as the length of the
            // first part.
            return firstPart.length;
        }
    }
    return firstPartIndentation;
}
function findMaxCommonIndentation(lines) {
    let minIndentation = Infinity;
    for (const line of lines) {
        minIndentation = Math.min(minIndentation, countLineIndentations(line));
    }
    return minIndentation;
}
function removeIndentation(line, indentation) {
    if (line.length < indentation) {
        return "";
    }
    return line.slice(indentation);
}
function removeAllIndentation(lines, indentation) {
    for (const line of lines) {
        line[0] = removeIndentation(line[0], indentation);
    }
}
function isEmptyLine(line) {
    if (line.length !== 1) {
        return false;
    }
    for (const char of line[0]) {
        if (char !== " ") {
            return false;
        }
    }
    return true;
}
function mergeLines(lines) {
    const linesAreEmpty = lines.map(isEmptyLine);
    const paragraphs = [];
    let currentParagraph = [];
    for (let i = 0; i < lines.length; i++) {
        if (linesAreEmpty[i]) {
            if (currentParagraph.length !== 0) {
                paragraphs.push(currentParagraph);
                currentParagraph = [];
            }
            continue;
        }
        if (currentParagraph.length !== 0) {
            const last = removeTrailingWhitespace(currentParagraph[currentParagraph.length - 1]);
            const next = removeLeadingWhitespace(lines[i][0]);
            currentParagraph[currentParagraph.length - 1] = last + " " + next;
            currentParagraph.push(...lines[i].slice(1));
        }
        else {
            currentParagraph.push(...lines[i]);
        }
    }
    if (currentParagraph.length !== 0) {
        paragraphs.push(currentParagraph);
    }
    return paragraphs;
}
function mergeParagraphs(paragraphs) {
    const result = [];
    if (paragraphs.length === 0) {
        return [""];
    }
    result.push(...paragraphs[0]);
    for (let i = 1; i < paragraphs.length; i++) {
        result[result.length - 1] += "\n\n" + paragraphs[i][0];
        result.push(...paragraphs[i].slice(1));
    }
    return result;
}
function addHolesForVariables(strings) {
    const result = [];
    for (let i = 0; i < strings.length; i++) {
        result.push(strings[i]);
        if (i < strings.length - 1) {
            result.push("");
        }
    }
    return result;
}
function compile(readonlyStrings) {
    const strings = [...readonlyStrings];
    strings[0] = removeLeadingNewlines(strings[0]);
    strings[strings.length - 1] = removeTrailingNewlinesAndWhitespace(strings[strings.length - 1]);
    const lines = breakIntoLines(strings);
    const commonIndentation = findMaxCommonIndentation(lines);
    removeAllIndentation(lines, commonIndentation);
    const paragraphs = mergeLines(lines);
    return addHolesForVariables(mergeParagraphs(paragraphs));
}
//

/***/ }),

/***/ 9891:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toJSONSafeNumber = void 0;
function toJSONSafeNumber(value) {
    if (!Number.isFinite(value)) {
        return undefined;
    }
    else if (Number.isNaN(value)) {
        return undefined;
    }
    else {
        return value;
    }
}
exports.toJSONSafeNumber = toJSONSafeNumber;
//

/***/ }),

/***/ 9662:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.failOk = exports.filteredArray = void 0;
const zod_1 = __webpack_require__(5995);
/**
 * Makes a Zod schema that filters out elements that do not match the provided schema.
 */
function filteredArray(schema) {
    return zod_1.z.array(zod_1.z.any()).transform(val => val
        .map(v => schema.safeParse(v))
        .filter(parsed => parsed.success)
        .map(parsed => parsed.data));
}
exports.filteredArray = filteredArray;
/**
 * Makes a Zod schema that turns a failed parse into an `undefined`.
 */
function failOk(schema) {
    return zod_1.z.any().transform(val => {
        const parsed = schema.safeParse(val);
        if (parsed.success) {
            return parsed.data;
        }
        return undefined;
    });
}
exports.failOk = failOk;
//

/***/ }),

/***/ 9602:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthenticatedWsClientTransport = void 0;
const WsAuthenticationResult_1 = __webpack_require__(7418);
const WsClientTransport_1 = __webpack_require__(7127);
class AuthenticatedWsClientTransport extends WsClientTransport_1.WsClientTransport {
    constructor(url, clientIdentifier, clientPasskey, receivedMessage, errored, parentLogger) {
        super(url, receivedMessage, errored, parentLogger);
        this.clientIdentifier = clientIdentifier;
        this.clientPasskey = clientPasskey;
        this.logger = this.logger.subclass("AuthenticatedWsClientTransport");
    }
    static createAuthenticatedWsClientTransportFactory({ url, clientIdentifier, clientPasskey, }) {
        return (receivedMessage, errored, parentLogger) => new AuthenticatedWsClientTransport(url, clientIdentifier, clientPasskey, receivedMessage, errored, parentLogger);
    }
    onWsOpen() {
        this.ws.send(JSON.stringify({
            authVersion: 1,
            clientIdentifier: this.clientIdentifier,
            clientPasskey: this.clientPasskey,
        }));
        this.ws.addEventListener("message", (event) => {
            try {
                const data = JSON.parse(event.data.toString("utf-8"));
                const result = WsAuthenticationResult_1.wsAuthenticationResultSchema.parse(data);
                if (result.success) {
                    super.onWsOpen();
                }
                else {
                    this.onWsError(new Error("Failed to authenticate: " + result.error));
                }
            }
            catch (error) {
                this.onWsError(new Error("Failed to parse authentication result: " + error?.message));
            }
        }, {
            once: true,
        });
    }
}
exports.AuthenticatedWsClientTransport = AuthenticatedWsClientTransport;
//

/***/ }),

/***/ 1973:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientPort = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_communication_1 = __webpack_require__(5305);
const lms_shared_types_1 = __webpack_require__(5790);
function defaultErrorDeserializer(serialized, stack) {
    const error = (0, lms_shared_types_1.fromSerializedError)(serialized);
    if (stack === undefined) {
        (0, lms_common_1.changeErrorStackInPlace)(error, "");
    }
    else {
        (0, lms_common_1.changeErrorStackInPlace)(error, stack);
    }
    return error;
}
class ClientPort {
    constructor(backendInterface, factory, { parentLogger, errorDeserializer, verboseErrorMessage, } = {}) {
        this.backendInterface = backendInterface;
        this.openChannels = new Map();
        this.ongoingRpcs = new Map();
        this.openCommunicationsCount = 0;
        this.nextChannelId = 0;
        this.producedCommunicationWarningsCount = 0;
        this.receivedMessage = (message) => {
            switch (message.type) {
                case "channelSend": {
                    this.receivedChannelSend(message);
                    break;
                }
                case "channelAck": {
                    this.receivedChannelAck(message);
                    break;
                }
                case "channelClose": {
                    this.receivedChannelClose(message);
                    break;
                }
                case "channelError": {
                    this.receivedChannelError(message);
                    break;
                }
                case "rpcResult": {
                    this.receivedRpcResult(message);
                    break;
                }
                case "rpcError": {
                    this.receivedRpcError(message);
                    break;
                }
                case "communicationWarning": {
                    this.receivedCommunicationWarning(message);
                    break;
                }
                case "keepAliveAck": {
                    this.receivedKeepAliveAck(message);
                    break;
                }
            }
        };
        this.errored = (error) => {
            for (const openChannel of this.openChannels.values()) {
                openChannel.errored(error);
            }
            for (const ongoingRpc of this.ongoingRpcs.values()) {
                ongoingRpc.reject(error);
            }
        };
        this.logger = new lms_common_1.SimpleLogger("ClientPort", parentLogger);
        this.errorDeserializer = errorDeserializer ?? defaultErrorDeserializer;
        this.verboseErrorMessage = verboseErrorMessage ?? false;
        this.transport = factory(this.receivedMessage, this.errored, this.logger);
    }
    communicationWarning(warning) {
        if (this.producedCommunicationWarningsCount >= 5) {
            return;
        }
        this.logger.warnText `
      Produced communication warning: ${warning}
      
      This is usually caused by communication protocol incompatibility. Please make sure you are
      using the up-to-date versions of the SDK and LM Studio.
    `;
        this.transport.send({
            type: "communicationWarning",
            warning,
        });
        this.producedCommunicationWarningsCount++;
        if (this.producedCommunicationWarningsCount >= 5) {
            this.logger.errorText `
        5 communication warnings have been produced. Further warnings will not be printed.
      `;
        }
    }
    updateOpenCommunicationsCount() {
        const previousCount = this.openCommunicationsCount;
        this.openCommunicationsCount = this.openChannels.size + this.ongoingRpcs.size;
        if (this.openCommunicationsCount === 0 && previousCount > 0) {
            this.transport.onHavingNoOpenCommunication();
        }
        else if (this.openCommunicationsCount === 1 && previousCount === 0) {
            this.transport.onHavingOneOrMoreOpenCommunication();
        }
    }
    receivedChannelSend(message) {
        const openChannel = this.openChannels.get(message.channelId);
        if (openChannel === undefined) {
            this.communicationWarning(`Received channelSend for unknown channel, channelId = ${message.channelId}`);
            return;
        }
        const parsed = openChannel.endpoint.toClientPacket.safeParse(message.message);
        if (!parsed.success) {
            this.communicationWarning((0, lms_common_1.text) `
        Received invalid message for channel: endpointName = ${openChannel.endpoint.name}, message =
        ${message.message}. Zod error:

        ${lms_common_1.Validator.prettyPrintZod("message", parsed.error)}
      `);
            return;
        }
        openChannel.receivedMessage(parsed.data);
    }
    receivedChannelAck(message) {
        const openChannel = this.openChannels.get(message.channelId);
        if (openChannel === undefined) {
            this.communicationWarning(`Received channelAck for unknown channel, channelId = ${message.channelId}`);
            return;
        }
        openChannel.receivedAck(message.ackId);
    }
    receivedChannelClose(message) {
        const openChannel = this.openChannels.get(message.channelId);
        if (openChannel === undefined) {
            this.communicationWarning(`Received channelClose for unknown channel, channelId = ${message.channelId}`);
            return;
        }
        this.openChannels.delete(message.channelId);
        openChannel.closed();
        this.updateOpenCommunicationsCount();
    }
    receivedChannelError(message) {
        const openChannel = this.openChannels.get(message.channelId);
        if (openChannel === undefined) {
            this.communicationWarning(`Received channelError for unknown channel, channelId = ${message.channelId}`);
            return;
        }
        this.openChannels.delete(message.channelId);
        const error = this.errorDeserializer(message.error, this.verboseErrorMessage ? openChannel.stack : undefined);
        openChannel.errored(error);
        this.updateOpenCommunicationsCount();
    }
    receivedRpcResult(message) {
        const ongoingRpc = this.ongoingRpcs.get(message.callId);
        if (ongoingRpc === undefined) {
            this.communicationWarning(`Received rpcResult for unknown rpc, callId = ${message.callId}`);
            return;
        }
        const parsed = ongoingRpc.endpoint.returns.safeParse(message.result);
        if (!parsed.success) {
            this.communicationWarning((0, lms_common_1.text) `
        Received invalid result for rpc, endpointName = ${ongoingRpc.endpoint.name}, result =
        ${message.result}. Zod error:

        ${lms_common_1.Validator.prettyPrintZod("result", parsed.error)}
      `);
            return;
        }
        ongoingRpc.resolve(parsed.data);
        this.ongoingRpcs.delete(message.callId);
        this.updateOpenCommunicationsCount();
    }
    receivedRpcError(message) {
        const ongoingRpc = this.ongoingRpcs.get(message.callId);
        if (ongoingRpc === undefined) {
            this.communicationWarning(`Received rpcError for unknown rpc, callId = ${message.callId}`);
            return;
        }
        const error = this.errorDeserializer(message.error, this.verboseErrorMessage ? ongoingRpc.stack : undefined);
        ongoingRpc.reject(error);
        this.ongoingRpcs.delete(message.callId);
        this.updateOpenCommunicationsCount();
    }
    receivedCommunicationWarning(message) {
        this.logger.warnText `
      Received communication warning from the server: ${message.warning}
      
      This is usually caused by communication protocol incompatibility. Please make sure you are
      using the up-to-date versions of the SDK and LM Studio.

      Note: This warning was received from the server and is printed on the client for convenience.
    `;
    }
    receivedKeepAliveAck(_message) {
        // Do nothing
    }
    async callRpc(endpointName, param, { stack } = {}) {
        const endpoint = this.backendInterface.getRpcEndpoint(endpointName);
        if (endpoint === undefined) {
            throw new Error(`No Rpc endpoint with name ${endpointName}`);
        }
        const parameter = endpoint.parameter.parse(param);
        const callId = this.nextChannelId;
        this.nextChannelId++;
        const { promise, resolve, reject } = (0, lms_common_1.makePromise)();
        stack = stack ?? (0, lms_common_1.getCurrentStack)(1);
        this.ongoingRpcs.set(callId, {
            endpoint,
            stack,
            resolve,
            reject,
        });
        this.transport.send({
            type: "rpcCall",
            endpoint: endpointName,
            callId,
            parameter,
        });
        this.updateOpenCommunicationsCount();
        return await promise;
    }
    createChannel(endpointName, param, onMessage, { stack } = {}) {
        const channelEndpoint = this.backendInterface.getChannelEndpoint(endpointName);
        if (channelEndpoint === undefined) {
            throw new Error(`No channel endpoint with name ${endpointName}`);
        }
        const creationParameter = channelEndpoint.creationParameter.parse(param);
        const channelId = this.nextChannelId;
        this.nextChannelId++;
        this.transport.send({
            type: "channelCreate",
            endpoint: endpointName,
            channelId,
            creationParameter,
        });
        stack = stack ?? (0, lms_common_1.getCurrentStack)(1);
        const openChannel = {
            endpoint: channelEndpoint,
            stack,
            ...lms_communication_1.Channel.create(packet => {
                const result = channelEndpoint.toServerPacket.parse(packet);
                this.transport.send({
                    type: "channelSend",
                    channelId,
                    message: result,
                });
            }),
        };
        if (onMessage !== undefined) {
            openChannel.channel.onMessage.subscribe(onMessage);
        }
        this.openChannels.set(channelId, openChannel);
        this.updateOpenCommunicationsCount();
        return openChannel.channel;
    }
}
exports.ClientPort = ClientPort;
//

/***/ }),

/***/ 5266:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenericClientTransport = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_communication_1 = __webpack_require__(5305);
class GenericClientTransport extends lms_communication_1.ClientTransport {
    constructor(onMessage, onClose, sendMessage, receivedMessage, errored, parentLogger) {
        super();
        this.sendMessage = sendMessage;
        this.receivedMessage = receivedMessage;
        this.errored = errored;
        this.closed = false;
        this.logger = new lms_common_1.SimpleLogger("GenericClientTransport", parentLogger);
        onMessage.subscribe(message => {
            let parsed;
            try {
                parsed = this.parseIncomingMessage(message);
            }
            catch (error) {
                this.logger.warn("Received invalid message from server:", message);
                return;
            }
            this.receivedMessage(parsed);
        });
        onClose.subscribeOnce(() => {
            if (this.closed) {
                return;
            }
            this.closed = true;
            this.errored(new Error("Server closed the connection"));
        });
    }
    static createFactory(onMessage, onClose, sendMessage) {
        return (receivedMessage, errored, parentLogger) => new GenericClientTransport(onMessage, onClose, sendMessage, receivedMessage, errored, parentLogger);
    }
    sendViaTransport(message) {
        this.sendMessage(message);
    }
}
exports.GenericClientTransport = GenericClientTransport;
//

/***/ }),

/***/ 7127:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WsClientTransport = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_communication_1 = __webpack_require__(5305);
const lms_isomorphic_1 = __webpack_require__(390);
var WsClientTransportStatus;
(function (WsClientTransportStatus) {
    WsClientTransportStatus["Disconnected"] = "DISCONNECTED";
    WsClientTransportStatus["Connecting"] = "CONNECTING";
    WsClientTransportStatus["Connected"] = "CONNECTED";
})(WsClientTransportStatus || (WsClientTransportStatus = {}));
class WsClientTransport extends lms_communication_1.ClientTransport {
    constructor(url, receivedMessage, errored, parentLogger) {
        super();
        this.url = url;
        this.receivedMessage = receivedMessage;
        this.errored = errored;
        this.ws = null;
        this.queuedMessages = [];
        this.status = WsClientTransportStatus.Disconnected;
        this.resolvedUrl = null;
        /**
         * Whether the underlying socket should hold the process open.
         */
        this.shouldRef = false;
        this.logger = new lms_common_1.SimpleLogger("WsClientTransport", parentLogger);
    }
    static createWsClientTransportFactory(url) {
        return (receivedMessage, errored, parentLogger) => new WsClientTransport(url, receivedMessage, errored, parentLogger);
    }
    connect() {
        if (this.status !== WsClientTransportStatus.Disconnected) {
            this.logger.warn("connect() called while not disconnected");
            return;
        }
        this.status = WsClientTransportStatus.Connecting;
        Promise.resolve(this.url).then(url => {
            this.resolvedUrl = url;
            this.ws = new lms_isomorphic_1.WebSocket(url);
            this.ws.addEventListener("open", this.onWsOpen.bind(this));
            this.ws.addEventListener("error", this.onWsError.bind(this));
        });
    }
    // private timeOut
    // private setupWebsocketKeepAlive(ws: WebSocket, onTimeout: () => void) {
    //   const socket = (ws as any)._socket as Socket | null | undefined;
    //   if (socket) {
    //     // Exists, use node.js methods
    //     socket.setKeepAlive(true, KEEP_ALIVE_INTERVAL);
    //     socket.setTimeout(KEEP_ALIVE_TIMEOUT, onTimeout);
    //   } else {
    //   }
    // }
    onWsOpen() {
        this.ws.addEventListener("message", this.onWsMessage.bind(this));
        this.status = WsClientTransportStatus.Connected;
        this.queuedMessages.forEach(message => this.sendViaTransport(message));
        this.queuedMessages = [];
        this.updateShouldRef(this.shouldRef);
        // this.setupWebsocketKeepAlive(this.ws!, this.onWsTimeout.bind(this));
    }
    onWsMessage(event) {
        if (this.status !== WsClientTransportStatus.Connected) {
            this.logger.warn("Received message while not connected. Message ignored:", event.data);
            return;
        }
        let message;
        try {
            message = JSON.parse(String(event.data));
        }
        catch (error) {
            this.logger.warn("Received invalid JSON message from server:", event.data);
            return;
        }
        let parsed;
        try {
            parsed = this.parseIncomingMessage(message);
        }
        catch (error) {
            this.logger.warn("Received invalid message from server:", message);
            return;
        }
        this.receivedMessage(parsed);
    }
    onWsError(event) {
        if (this.status === WsClientTransportStatus.Disconnected) {
            return;
        }
        this.logger.warn("WebSocket error:", event.error);
        if (event.error.code === "ECONNREFUSED") {
            this.logger.warnText `
          WebSocket connection refused. This can happen if the server is not running or the client
          is trying to connect to the wrong path. The server path that this client is
          attempting to connect to is:
          ${this.resolvedUrl ?? "Unknown" /* Should never be Unknown */}.

          Please make sure the following:

            1. LM Studio is running

            2. The API server in LM Studio has started

            3. The client is attempting to connect to the correct path
        `;
        }
        try {
            this.ws?.close();
        }
        catch (error) {
            // Ignore
        }
        this.status = WsClientTransportStatus.Disconnected;
        this.errored(event);
    }
    onWsTimeout() {
        if (this.status === WsClientTransportStatus.Disconnected) {
            return;
        }
        this.logger.warn("Websocket timed out");
        try {
            this.ws?.close();
        }
        catch (error) {
            // Ignore
        }
        this.status = WsClientTransportStatus.Disconnected;
        this.errored(new Error("WebSocket timed out"));
    }
    onHavingNoOpenCommunication() {
        this.updateShouldRef(false);
    }
    onHavingOneOrMoreOpenCommunication() {
        this.updateShouldRef(true);
    }
    updateShouldRef(shouldRef) {
        this.shouldRef = shouldRef;
        if (this.ws === null) {
            return;
        }
        if (!this.ws._socket) {
            return;
        }
        if (shouldRef) {
            this.ws._socket.ref();
        }
        else {
            this.ws._socket.unref();
        }
    }
    sendViaTransport(message) {
        if (this.status === WsClientTransportStatus.Connected) {
            this.ws.send(JSON.stringify(message));
        }
        else {
            this.queuedMessages.push(message);
            if (this.status === WsClientTransportStatus.Disconnected) {
                this.connect();
            }
        }
    }
}
exports.WsClientTransport = WsClientTransport;
//

/***/ }),

/***/ 3697:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WsClientTransport = exports.GenericClientTransport = exports.ClientPort = exports.AuthenticatedWsClientTransport = void 0;
var AuthenticatedWsClientTransport_1 = __webpack_require__(9602);
Object.defineProperty(exports, "AuthenticatedWsClientTransport", ({ enumerable: true, get: function () { return AuthenticatedWsClientTransport_1.AuthenticatedWsClientTransport; } }));
var ClientPort_1 = __webpack_require__(1973);
Object.defineProperty(exports, "ClientPort", ({ enumerable: true, get: function () { return ClientPort_1.ClientPort; } }));
var GenericClientTransport_1 = __webpack_require__(5266);
Object.defineProperty(exports, "GenericClientTransport", ({ enumerable: true, get: function () { return GenericClientTransport_1.GenericClientTransport; } }));
var WsClientTransport_1 = __webpack_require__(7127);
Object.defineProperty(exports, "WsClientTransport", ({ enumerable: true, get: function () { return WsClientTransport_1.WsClientTransport; } }));
//

/***/ }),

/***/ 7158:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BackendInterface = void 0;
/* eslint-disable @typescript-eslint/ban-types */
const zod_1 = __webpack_require__(5995);
class BackendInterface {
    constructor() {
        this.unhandledEndpoints = new Set();
        this.existingEndpointNames = new Set();
        this.rpcEndpoints = new Map();
        this.channelEndpoints = new Map();
    }
    withContextType() {
        return this;
    }
    assertEndpointNameNotExists(endpointName) {
        if (this.existingEndpointNames.has(endpointName)) {
            throw new Error(`Endpoint with name ${endpointName} already exists`);
        }
    }
    /**
     * Register an Rpc endpoint.
     */
    addRpcEndpoint(endpointName, { parameter, returns, }) {
        this.assertEndpointNameNotExists(endpointName);
        this.existingEndpointNames.add(endpointName);
        this.rpcEndpoints.set(endpointName, {
            name: endpointName,
            parameter,
            returns,
            handler: null,
        });
        return this;
    }
    addChannelEndpoint(endpointName, { creationParameter, toServerPacket, toClientPacket, }) {
        this.assertEndpointNameNotExists(endpointName);
        this.existingEndpointNames.add(endpointName);
        this.channelEndpoints.set(endpointName, {
            name: endpointName,
            creationParameter,
            toServerPacket,
            toClientPacket,
            handler: null,
        });
        return this;
    }
    addSignalEndpoint(endpointName, { creationParameter, signalData, }) {
        return this.addChannelEndpoint(endpointName, {
            creationParameter,
            toServerPacket: zod_1.z.undefined(),
            toClientPacket: signalData,
        });
    }
    /**
     * Adds a handler for an Rpc endpoint.
     */
    handleRpcEndpoint(endpointName, handler) {
        const endpoint = this.rpcEndpoints.get(endpointName);
        if (endpoint === undefined) {
            throw new Error(`No Rpc endpoint with name ${endpointName}`);
        }
        if (endpoint.handler !== null) {
            throw new Error(`Rpc endpoint with name ${endpointName} already has a handler`);
        }
        endpoint.handler = handler;
        this.unhandledEndpoints.delete(endpointName);
    }
    /**
     * Adds a handler for a channel endpoint.
     */
    handleChannelEndpoint(endpointName, handler) {
        const endpoint = this.channelEndpoints.get(endpointName);
        if (endpoint === undefined) {
            throw new Error(`No channel endpoint with name ${endpointName}`);
        }
        if (endpoint.handler !== null) {
            throw new Error(`Channel endpoint with name ${endpointName} already has a handler`);
        }
        endpoint.handler = handler;
        this.unhandledEndpoints.delete(endpointName);
    }
    assertAllEndpointsHandled() {
        if (this.unhandledEndpoints.size > 0) {
            throw new Error(`The following endpoints were not handled: ${Array.from(this.unhandledEndpoints).join(", ")}`);
        }
    }
    getRpcEndpoint(endpointName) {
        return this.rpcEndpoints.get(endpointName);
    }
    getChannelEndpoint(endpointName) {
        return this.channelEndpoints.get(endpointName);
    }
}
exports.BackendInterface = BackendInterface;
//

/***/ }),

/***/ 3142:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Channel = exports.ConnectionStatus = void 0;
const lms_common_1 = __webpack_require__(2934);
var ConnectionStatus;
(function (ConnectionStatus) {
    /**
     * The underlying transport is connected and is communicating properly.
     */
    ConnectionStatus["Connected"] = "CONNECTED";
    /**
     * The underlying transport has errored out.
     */
    ConnectionStatus["Errored"] = "ERRORED";
    /**
     * The channel has been properly closed and no more messages will be sent or received.
     */
    ConnectionStatus["Closed"] = "CLOSED";
})(ConnectionStatus || (exports.ConnectionStatus = ConnectionStatus = {}));
const logger = new lms_common_1.SimpleLogger("Channel");
class Channel {
    constructor(innerSend) {
        this.innerSend = innerSend;
        this.nextAckId = 0;
        /**
         * A map for messages that are waiting for an ACK. The values are the functions to resolve or
         * reject the corresponding promise.
         */
        this.waitingForAck = new Map();
        /**
         * Returned as a part of create. It should be called by the controlling port.
         */
        this.receivedACK = (ackId) => {
            if (this.connectionStatus.get() !== ConnectionStatus.Connected) {
                logger.warn("Received ACK while in status", this.connectionStatus.get());
                return;
            }
            const waiting = this.waitingForAck.get(ackId);
            if (waiting === undefined) {
                logger.warn("Received ACK for a message that is no longer waiting for ACK, ackId =", ackId);
                return;
            }
            waiting.resolve();
        };
        /**
         * Returned as a part of create. It should be called by the controlling port.
         */
        this.receivedMessage = (packet) => {
            if (this.connectionStatus.get() !== ConnectionStatus.Connected) {
                logger.warn("Received message while in status", this.connectionStatus.get());
                return;
            }
            this.emitOnMessage(packet);
        };
        /**
         * Returned as a part of create. It should be called by the controlling port.
         */
        this.errored = (error) => {
            if (this.connectionStatus.get() !== ConnectionStatus.Connected) {
                logger.warn("Received error while in status", this.connectionStatus.get());
                return;
            }
            this.rejectAllWaitingForAck(error);
            this.setConnectionStatus(ConnectionStatus.Errored);
            this.emitOnError(error);
        };
        /**
         * Returned as a part of create. It should be called by the controlling port.
         */
        this.closed = () => {
            this.rejectAllWaitingForAck(new Error("Channel closed"));
            this.setConnectionStatus(ConnectionStatus.Closed);
            this.emitOnClose();
        };
        [this.onMessage, this.emitOnMessage] = lms_common_1.BufferedEvent.create();
        [this.onError, this.emitOnError] = lms_common_1.BufferedEvent.create();
        [this.onClose, this.emitOnClose] = lms_common_1.BufferedEvent.create();
        [this.connectionStatus, this.setConnectionStatus] = lms_common_1.Signal.create(ConnectionStatus.Connected);
    }
    rejectAllWaitingForAck(error) {
        const rejects = Array.from(this.waitingForAck.values()).map(({ reject }) => reject);
        this.waitingForAck.clear();
        for (const reject of rejects) {
            reject(error);
        }
    }
    static create(innerSend) {
        const channel = new Channel(innerSend);
        return {
            channel,
            receivedAck: channel.receivedACK,
            receivedMessage: channel.receivedMessage,
            errored: channel.errored,
            closed: channel.closed,
        };
    }
    send(packet) {
        this.innerSend(packet);
    }
    sendAndWaitForACK(packet) {
        const { promise, resolve, reject } = (0, lms_common_1.makePromise)();
        const ackId = this.nextAckId;
        this.nextAckId++;
        this.waitingForAck.set(ackId, { resolve, reject });
        this.innerSend(packet, ackId);
        return promise;
    }
}
exports.Channel = Channel;
//

/***/ }),

/***/ 5156:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServerTransport = exports.ClientTransport = exports.Transport = void 0;
const lms_shared_types_1 = __webpack_require__(5790);
const zod_1 = __webpack_require__(5995);
const clientToServerMessageSchema = zod_1.z.discriminatedUnion("type", [
    zod_1.z.object({
        type: zod_1.z.literal("channelCreate"),
        endpoint: zod_1.z.string(),
        channelId: zod_1.z.number(),
        creationParameter: zod_1.z.any(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("channelSend"),
        channelId: zod_1.z.number(),
        message: zod_1.z.any(),
        ackId: zod_1.z.number().optional(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("channelAck"),
        channelId: zod_1.z.number(),
        ackId: zod_1.z.number(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("rpcCall"),
        endpoint: zod_1.z.string(),
        callId: zod_1.z.number(),
        parameter: zod_1.z.any(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("communicationWarning"),
        warning: zod_1.z.string(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("keepAlive"),
    }),
]);
const serverToClientMessageSchema = zod_1.z.discriminatedUnion("type", [
    zod_1.z.object({
        type: zod_1.z.literal("channelSend"),
        channelId: zod_1.z.number(),
        message: zod_1.z.any(),
        ackId: zod_1.z.number().optional(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("channelAck"),
        channelId: zod_1.z.number(),
        ackId: zod_1.z.number(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("channelClose"),
        channelId: zod_1.z.number(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("channelError"),
        channelId: zod_1.z.number(),
        error: lms_shared_types_1.serializedLMSExtendedErrorSchema,
    }),
    zod_1.z.object({
        type: zod_1.z.literal("rpcResult"),
        callId: zod_1.z.number(),
        result: zod_1.z.any(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("rpcError"),
        callId: zod_1.z.number(),
        error: lms_shared_types_1.serializedLMSExtendedErrorSchema,
    }),
    zod_1.z.object({
        type: zod_1.z.literal("communicationWarning"),
        warning: zod_1.z.string(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("keepAliveAck"),
    }),
]);
class Transport {
}
exports.Transport = Transport;
class ClientTransport extends Transport {
    parseIncomingMessage(message) {
        return serverToClientMessageSchema.parse(message);
    }
    send(message) {
        const result = clientToServerMessageSchema.parse(message);
        this.sendViaTransport(result);
    }
    /**
     * Called by the client port when the number of open communications changes from 0 to 1. This
     * usually indicates the `socket.ref()` should be called to prevent the process from exiting.
     */
    onHavingOneOrMoreOpenCommunication() { }
    /**
     * Called by the client port when the number of open communications changes from 1 or more to 0.
     * This usually indicates the `socket.unref()` should be called to allow the process to exit.
     */
    onHavingNoOpenCommunication() { }
}
exports.ClientTransport = ClientTransport;
class ServerTransport extends Transport {
    parseIncomingMessage(message) {
        return clientToServerMessageSchema.parse(message);
    }
    send(message) {
        const result = serverToClientMessageSchema.parse(message);
        this.sendViaTransport(result);
    }
}
exports.ServerTransport = ServerTransport;
//

/***/ }),

/***/ 7418:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wsAuthenticationResultSchema = void 0;
const zod_1 = __webpack_require__(5995);
exports.wsAuthenticationResultSchema = zod_1.z.discriminatedUnion("success", [
    zod_1.z.object({
        success: zod_1.z.literal(true),
    }),
    zod_1.z.object({
        success: zod_1.z.literal(false),
        error: zod_1.z.string(),
    }),
]);
//

/***/ }),

/***/ 7929:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.authPacketSchema = void 0;
const zod_1 = __webpack_require__(5995);
exports.authPacketSchema = zod_1.z.object({
    authVersion: zod_1.z.literal(1),
    clientIdentifier: zod_1.z.string().max(256),
    clientPasskey: zod_1.z.string().max(256),
});
//

/***/ }),

/***/ 5305:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KEEP_ALIVE_TIMEOUT = exports.KEEP_ALIVE_INTERVAL = exports.authPacketSchema = exports.ServerTransport = exports.ClientTransport = exports.Channel = exports.BackendInterface = void 0;
var BackendInterface_1 = __webpack_require__(7158);
Object.defineProperty(exports, "BackendInterface", ({ enumerable: true, get: function () { return BackendInterface_1.BackendInterface; } }));
var Channel_1 = __webpack_require__(3142);
Object.defineProperty(exports, "Channel", ({ enumerable: true, get: function () { return Channel_1.Channel; } }));
var Transport_1 = __webpack_require__(5156);
Object.defineProperty(exports, "ClientTransport", ({ enumerable: true, get: function () { return Transport_1.ClientTransport; } }));
Object.defineProperty(exports, "ServerTransport", ({ enumerable: true, get: function () { return Transport_1.ServerTransport; } }));
var authentication_1 = __webpack_require__(7929);
Object.defineProperty(exports, "authPacketSchema", ({ enumerable: true, get: function () { return authentication_1.authPacketSchema; } }));
var timeoutConstants_1 = __webpack_require__(5621);
Object.defineProperty(exports, "KEEP_ALIVE_INTERVAL", ({ enumerable: true, get: function () { return timeoutConstants_1.KEEP_ALIVE_INTERVAL; } }));
Object.defineProperty(exports, "KEEP_ALIVE_TIMEOUT", ({ enumerable: true, get: function () { return timeoutConstants_1.KEEP_ALIVE_TIMEOUT; } }));
//

/***/ }),

/***/ 5621:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KEEP_ALIVE_TIMEOUT = exports.KEEP_ALIVE_INTERVAL = void 0;
exports.KEEP_ALIVE_INTERVAL = 5000;
exports.KEEP_ALIVE_TIMEOUT = 15000;
//

/***/ }),

/***/ 7364:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDiagnosticsBackendInterface = void 0;
const lms_communication_1 = __webpack_require__(5305);
const lms_shared_types_1 = __webpack_require__(5790);
const zod_1 = __webpack_require__(5995);
function createDiagnosticsBackendInterface() {
    return new lms_communication_1.BackendInterface()
        .addRpcEndpoint("echo", {
        parameter: zod_1.z.string(),
        returns: zod_1.z.string(),
    })
        .addChannelEndpoint("streamLogs", {
        creationParameter: zod_1.z.void(),
        toServerPacket: zod_1.z.discriminatedUnion("type", [
            zod_1.z.object({
                type: zod_1.z.literal("stop"),
            }),
        ]),
        toClientPacket: zod_1.z.discriminatedUnion("type", [
            zod_1.z.object({
                type: zod_1.z.literal("log"),
                log: lms_shared_types_1.diagnosticsLogEventSchema,
            }),
        ]),
    });
}
exports.createDiagnosticsBackendInterface = createDiagnosticsBackendInterface;
//

/***/ }),

/***/ 6853:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createLlmBackendInterface = void 0;
const lms_communication_1 = __webpack_require__(5305);
const lms_shared_types_1 = __webpack_require__(5790);
const LLMPredictionConfig_1 = __webpack_require__(7486);
const zod_1 = __webpack_require__(5995);
function createLlmBackendInterface() {
    return new lms_communication_1.BackendInterface()
        .addRpcEndpoint("echo", {
        parameter: zod_1.z.string(),
        returns: zod_1.z.string(),
    })
        .addChannelEndpoint("loadModel", {
        creationParameter: zod_1.z.object({
            path: zod_1.z.string(),
            identifier: zod_1.z.string().optional(),
            preset: zod_1.z.string().optional(),
            config: lms_shared_types_1.llmLoadModelConfigSchema,
            noHup: zod_1.z.boolean(),
        }),
        toClientPacket: zod_1.z.discriminatedUnion("type", [
            zod_1.z.object({
                type: zod_1.z.literal("progress"),
                progress: zod_1.z.number(),
            }),
            zod_1.z.object({
                type: zod_1.z.literal("success"),
                sessionIdentifier: zod_1.z.string(),
            }),
        ]),
        toServerPacket: zod_1.z.discriminatedUnion("type", [
            zod_1.z.object({
                type: zod_1.z.literal("cancel"),
            }),
        ]),
    })
        .addRpcEndpoint("unloadModel", {
        parameter: zod_1.z.object({
            identifier: zod_1.z.string(),
        }),
        returns: zod_1.z.void(),
    })
        .addChannelEndpoint("predict", {
        creationParameter: zod_1.z.object({
            modelSpecifier: lms_shared_types_1.llmModelSpecifierSchema,
            history: lms_shared_types_1.llmChatHistorySchema,
            config: LLMPredictionConfig_1.llmFullPredictionConfigSchema,
            structured: lms_shared_types_1.llmStructuredPredictionSettingSchema.optional(),
        }),
        toClientPacket: zod_1.z.discriminatedUnion("type", [
            zod_1.z.object({
                type: zod_1.z.literal("fragment"),
                fragment: zod_1.z.string(),
            }),
            zod_1.z.object({
                type: zod_1.z.literal("success"),
                stats: lms_shared_types_1.llmPredictionStatsSchema,
                modelInfo: lms_shared_types_1.llmDescriptorSchema,
            }),
        ]),
        toServerPacket: zod_1.z.discriminatedUnion("type", [
            zod_1.z.object({
                type: zod_1.z.literal("cancel"),
            }),
        ]),
    })
        .addRpcEndpoint("listLoaded", {
        parameter: zod_1.z.undefined(),
        returns: zod_1.z.array(lms_shared_types_1.llmDescriptorSchema),
    })
        .addRpcEndpoint("getModelInfo", {
        parameter: zod_1.z.object({
            specifier: lms_shared_types_1.llmModelSpecifierSchema,
            throwIfNotFound: zod_1.z.boolean(),
        }),
        returns: zod_1.z
            .object({
            sessionIdentifier: zod_1.z.string(),
            descriptor: lms_shared_types_1.llmDescriptorSchema,
        })
            .optional(),
    });
}
exports.createLlmBackendInterface = createLlmBackendInterface;
//

/***/ }),

/***/ 3204:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.downloadedModelSchema = void 0;
const zod_1 = __webpack_require__(5995);
exports.downloadedModelSchema = zod_1.z.discriminatedUnion("type", [
    zod_1.z.object({
        type: zod_1.z.enum(["llm", "embedding"]),
        path: zod_1.z.string(),
        sizeBytes: zod_1.z.number(),
        architecture: zod_1.z.string().optional(),
    }),
]);
//

/***/ }),

/***/ 4284:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromSerializedError = exports.attachSerializedErrorData = exports.serializeError = exports.serializedLMSExtendedErrorSchema = exports.errorDisplayDataSchema = void 0;
const zod_1 = __webpack_require__(5995);
const LLMErrorDisplayData_1 = __webpack_require__(8469);
exports.errorDisplayDataSchema = zod_1.z.discriminatedUnion("code", [...LLMErrorDisplayData_1.llmErrorDisplayDataSchema]);
/**
 * Makes a Zod schema that turns a failed parse into an `undefined`.
 */
function failOk(schema) {
    return zod_1.z.any().transform(val => (schema.safeParse(val).success ? val : undefined));
}
exports.serializedLMSExtendedErrorSchema = zod_1.z.object({
    title: zod_1.z.string(),
    cause: zod_1.z.string().optional(),
    suggestion: zod_1.z.string().optional(),
    errorData: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()).optional(),
    displayData: failOk(exports.errorDisplayDataSchema).optional(),
});
function serializeError(error) {
    if (typeof error === "object") {
        return {
            title: error.title ?? error.message ?? "Unknown error",
            cause: error.cause,
            suggestion: error.suggestion,
            errorData: error.errorData,
            displayData: error.displayData,
        };
    }
    else {
        return {
            title: String(error),
        };
    }
}
exports.serializeError = serializeError;
/**
 * Attaches the additional error data from a serialized error to an error object.
 */
function attachSerializedErrorData(error, serialized) {
    const untypedError = error;
    if (serialized.cause !== undefined) {
        untypedError.cause = serialized.cause;
    }
    if (serialized.suggestion !== undefined) {
        untypedError.suggestion = serialized.suggestion;
    }
    if (serialized.errorData !== undefined) {
        untypedError.errorData = serialized.errorData;
    }
}
exports.attachSerializedErrorData = attachSerializedErrorData;
function fromSerializedError(error) {
    const result = new Error(error.title);
    result.name = "LMStudioError";
    attachSerializedErrorData(result, error);
    return result;
}
exports.fromSerializedError = fromSerializedError;
//

/***/ }),

/***/ 5221:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.jsonSerializableSchema = void 0;
const zod_1 = __webpack_require__(5995);
exports.jsonSerializableSchema = zod_1.z.any().transform((val, ctx) => {
    try {
        return JSON.parse(JSON.stringify(val));
    }
    catch (e) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: "Not JSON serializable: " + e.message,
        });
        return val;
    }
});
//

/***/ }),

/***/ 8322:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runtimeSchema = exports.acceleratorSchema = exports.acceleratorTypeSchema = void 0;
const zod_1 = __webpack_require__(5995);
exports.acceleratorTypeSchema = zod_1.z.enum(["unknown", "integratedGpu", "dedicatedGpu"]);
exports.acceleratorSchema = zod_1.z.object({
    name: zod_1.z.string(),
    deviceId: zod_1.z.number(),
    totalMemoryBytes: zod_1.z.number(),
    type: exports.acceleratorTypeSchema,
});
exports.runtimeSchema = zod_1.z.object({
    key: zod_1.z.string(),
    name: zod_1.z.string(),
    accelerators: zod_1.z.array(exports.acceleratorSchema),
});
//

/***/ }),

/***/ 5939:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.diagnosticsLogEventSchema = exports.diagnosticsLogEventDataSchema = void 0;
const zod_1 = __webpack_require__(5995);
exports.diagnosticsLogEventDataSchema = zod_1.z.discriminatedUnion("type", [
    zod_1.z.object({
        type: zod_1.z.literal("llm.prediction.input"),
        modelPath: zod_1.z.string(),
        modelIdentifier: zod_1.z.string(),
        input: zod_1.z.string(),
    }),
]);
exports.diagnosticsLogEventSchema = zod_1.z.object({
    timestamp: zod_1.z.number(),
    data: exports.diagnosticsLogEventDataSchema,
});
//

/***/ }),

/***/ 5790:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runtimeSchema = exports.acceleratorTypeSchema = exports.acceleratorSchema = exports.reasonableKeyStringSchema = exports.llmStructuredPredictionSettingSchema = exports.llmPredictionStopReasonSchema = exports.llmPredictionStatsSchema = exports.llmFullPredictionConfigSchema = exports.llmContextOverflowPolicySchema = exports.llmCompletionPredictionConfigSchema = exports.llmChatPredictionConfigSchema = exports.llmModelSpecifierSchema = exports.llmModelQuerySchema = exports.llmLoadModelConfigSchema = exports.llmAccelerationOffloadSchema = exports.llmDescriptorSchema = exports.llmChatHistorySchema = exports.llmChatHistoryRoleSchema = exports.llmChatHistoryMessageSchema = exports.serializeError = exports.serializedLMSExtendedErrorSchema = exports.fromSerializedError = exports.errorDisplayDataSchema = exports.attachSerializedErrorData = exports.downloadedModelSchema = exports.diagnosticsLogEventSchema = exports.diagnosticsLogEventDataSchema = exports.logLevelSchema = void 0;
const zod_1 = __webpack_require__(5995);
exports.logLevelSchema = zod_1.z.enum(["debug", "info", "warn", "error"]);
var DiagnosticsLogEvent_1 = __webpack_require__(5939);
Object.defineProperty(exports, "diagnosticsLogEventDataSchema", ({ enumerable: true, get: function () { return DiagnosticsLogEvent_1.diagnosticsLogEventDataSchema; } }));
Object.defineProperty(exports, "diagnosticsLogEventSchema", ({ enumerable: true, get: function () { return DiagnosticsLogEvent_1.diagnosticsLogEventSchema; } }));
var DownloadedModel_1 = __webpack_require__(3204);
Object.defineProperty(exports, "downloadedModelSchema", ({ enumerable: true, get: function () { return DownloadedModel_1.downloadedModelSchema; } }));
var Error_1 = __webpack_require__(4284);
Object.defineProperty(exports, "attachSerializedErrorData", ({ enumerable: true, get: function () { return Error_1.attachSerializedErrorData; } }));
Object.defineProperty(exports, "errorDisplayDataSchema", ({ enumerable: true, get: function () { return Error_1.errorDisplayDataSchema; } }));
Object.defineProperty(exports, "fromSerializedError", ({ enumerable: true, get: function () { return Error_1.fromSerializedError; } }));
Object.defineProperty(exports, "serializedLMSExtendedErrorSchema", ({ enumerable: true, get: function () { return Error_1.serializedLMSExtendedErrorSchema; } }));
Object.defineProperty(exports, "serializeError", ({ enumerable: true, get: function () { return Error_1.serializeError; } }));
var LLMChatHistory_1 = __webpack_require__(6427);
Object.defineProperty(exports, "llmChatHistoryMessageSchema", ({ enumerable: true, get: function () { return LLMChatHistory_1.llmChatHistoryMessageSchema; } }));
Object.defineProperty(exports, "llmChatHistoryRoleSchema", ({ enumerable: true, get: function () { return LLMChatHistory_1.llmChatHistoryRoleSchema; } }));
Object.defineProperty(exports, "llmChatHistorySchema", ({ enumerable: true, get: function () { return LLMChatHistory_1.llmChatHistorySchema; } }));
var LLMDescriptor_1 = __webpack_require__(8540);
Object.defineProperty(exports, "llmDescriptorSchema", ({ enumerable: true, get: function () { return LLMDescriptor_1.llmDescriptorSchema; } }));
var LLMLoadModelConfig_1 = __webpack_require__(5974);
Object.defineProperty(exports, "llmAccelerationOffloadSchema", ({ enumerable: true, get: function () { return LLMLoadModelConfig_1.llmAccelerationOffloadSchema; } }));
Object.defineProperty(exports, "llmLoadModelConfigSchema", ({ enumerable: true, get: function () { return LLMLoadModelConfig_1.llmLoadModelConfigSchema; } }));
var LLMModelSpecifier_1 = __webpack_require__(4126);
Object.defineProperty(exports, "llmModelQuerySchema", ({ enumerable: true, get: function () { return LLMModelSpecifier_1.llmModelQuerySchema; } }));
Object.defineProperty(exports, "llmModelSpecifierSchema", ({ enumerable: true, get: function () { return LLMModelSpecifier_1.llmModelSpecifierSchema; } }));
var LLMPredictionConfig_1 = __webpack_require__(7486);
Object.defineProperty(exports, "llmChatPredictionConfigSchema", ({ enumerable: true, get: function () { return LLMPredictionConfig_1.llmChatPredictionConfigSchema; } }));
Object.defineProperty(exports, "llmCompletionPredictionConfigSchema", ({ enumerable: true, get: function () { return LLMPredictionConfig_1.llmCompletionPredictionConfigSchema; } }));
Object.defineProperty(exports, "llmContextOverflowPolicySchema", ({ enumerable: true, get: function () { return LLMPredictionConfig_1.llmContextOverflowPolicySchema; } }));
Object.defineProperty(exports, "llmFullPredictionConfigSchema", ({ enumerable: true, get: function () { return LLMPredictionConfig_1.llmFullPredictionConfigSchema; } }));
var LLMPredictionStats_1 = __webpack_require__(6653);
Object.defineProperty(exports, "llmPredictionStatsSchema", ({ enumerable: true, get: function () { return LLMPredictionStats_1.llmPredictionStatsSchema; } }));
Object.defineProperty(exports, "llmPredictionStopReasonSchema", ({ enumerable: true, get: function () { return LLMPredictionStats_1.llmPredictionStopReasonSchema; } }));
var LLMStructuredPredictionSetting_1 = __webpack_require__(5943);
Object.defineProperty(exports, "llmStructuredPredictionSettingSchema", ({ enumerable: true, get: function () { return LLMStructuredPredictionSetting_1.llmStructuredPredictionSettingSchema; } }));
var reasonable_1 = __webpack_require__(4324);
Object.defineProperty(exports, "reasonableKeyStringSchema", ({ enumerable: true, get: function () { return reasonable_1.reasonableKeyStringSchema; } }));
var Runtime_1 = __webpack_require__(8322);
Object.defineProperty(exports, "acceleratorSchema", ({ enumerable: true, get: function () { return Runtime_1.acceleratorSchema; } }));
Object.defineProperty(exports, "acceleratorTypeSchema", ({ enumerable: true, get: function () { return Runtime_1.acceleratorTypeSchema; } }));
Object.defineProperty(exports, "runtimeSchema", ({ enumerable: true, get: function () { return Runtime_1.runtimeSchema; } }));
//

/***/ }),

/***/ 6427:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmChatHistorySchema = exports.llmChatHistoryMessageSchema = exports.llmChatHistoryRoleSchema = void 0;
const zod_1 = __webpack_require__(5995);
exports.llmChatHistoryRoleSchema = zod_1.z
    .string()
    .refine(v => ["system", "user", "assistant"].includes(v), {
    message: "Invalid role, must be one of 'system', 'user', or 'assistant'",
});
exports.llmChatHistoryMessageSchema = zod_1.z.object({
    role: exports.llmChatHistoryRoleSchema,
    content: zod_1.z.string(),
});
exports.llmChatHistorySchema = zod_1.z.array(exports.llmChatHistoryMessageSchema);
//

/***/ }),

/***/ 8540:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmDescriptorSchema = void 0;
const zod_1 = __webpack_require__(5995);
exports.llmDescriptorSchema = zod_1.z.object({
    identifier: zod_1.z.string(),
    path: zod_1.z.string(),
});
//

/***/ }),

/***/ 8469:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmErrorDisplayDataSchema = void 0;
const zod_1 = __webpack_require__(5995);
const LLMModelSpecifier_1 = __webpack_require__(4126);
exports.llmErrorDisplayDataSchema = [
    zod_1.z.object({
        code: zod_1.z.literal("llm.pathNotFound"),
        path: zod_1.z.string(),
        availablePathsSample: zod_1.z.array(zod_1.z.string()),
        totalModels: zod_1.z.number(),
    }),
    zod_1.z.object({
        code: zod_1.z.literal("llm.identifierNotFound"),
        identifier: zod_1.z.string(),
        loadedModelsSample: zod_1.z.array(zod_1.z.string()),
        totalLoadedModels: zod_1.z.number(),
    }),
    zod_1.z.object({
        code: zod_1.z.literal("llm.specificModelUnloaded"),
    }),
    zod_1.z.object({
        code: zod_1.z.literal("llm.noModelMatchingQuery"),
        query: LLMModelSpecifier_1.llmModelQuerySchema,
        loadedModelsSample: zod_1.z.array(zod_1.z.string()),
        totalLoadedModels: zod_1.z.number(),
    }),
];
//

/***/ }),

/***/ 5974:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmLoadModelConfigSchema = exports.llmAccelerationOffloadSchema = void 0;
const zod_1 = __webpack_require__(5995);
exports.llmAccelerationOffloadSchema = zod_1.z.union([
    zod_1.z.number().min(0).max(1),
    zod_1.z.literal("auto"),
    zod_1.z.literal("max"),
    zod_1.z.literal("off"),
]);
exports.llmLoadModelConfigSchema = zod_1.z.object({
    contextLength: zod_1.z.number().int().min(0).optional(),
    gpuOffload: exports.llmAccelerationOffloadSchema.optional(),
});
//

/***/ }),

/***/ 4126:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmModelSpecifierSchema = exports.llmModelQuerySchema = void 0;
const zod_1 = __webpack_require__(5995);
const reasonable_1 = __webpack_require__(4324);
exports.llmModelQuerySchema = zod_1.z.object({
    identifier: reasonable_1.reasonableKeyStringSchema.optional(),
    path: reasonable_1.reasonableKeyStringSchema.optional(),
});
exports.llmModelSpecifierSchema = zod_1.z.discriminatedUnion("type", [
    zod_1.z.object({
        type: zod_1.z.literal("query"),
        query: exports.llmModelQuerySchema,
    }),
    zod_1.z.object({
        type: zod_1.z.literal("sessionIdentifier"),
        sessionIdentifier: zod_1.z.string(),
    }),
]);
//

/***/ }),

/***/ 7486:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmFullPredictionConfigSchema = exports.llmChatPredictionConfigSchema = exports.llmCompletionPredictionConfigSchema = exports.llmContextOverflowPolicySchema = void 0;
const zod_1 = __webpack_require__(5995);
exports.llmContextOverflowPolicySchema = zod_1.z.enum([
    "stopAtLimit",
    "truncateMiddle",
    "rollingWindow",
]);
const llmPredictionConfigBaseSchema = zod_1.z.object({
    maxPredictedTokens: zod_1.z.number().int().min(-1).optional(),
    temperature: zod_1.z.number().min(0).max(1).optional(),
    stopStrings: zod_1.z.array(zod_1.z.string()).optional(),
    contextOverflowPolicy: exports.llmContextOverflowPolicySchema.optional(),
});
exports.llmCompletionPredictionConfigSchema = llmPredictionConfigBaseSchema.extend({
    prePrompt: zod_1.z.string().optional(),
});
exports.llmChatPredictionConfigSchema = llmPredictionConfigBaseSchema.extend({
    inputPrefix: zod_1.z.string().optional(),
    inputSuffix: zod_1.z.string().optional(),
});
exports.llmFullPredictionConfigSchema = zod_1.z.object({
    ...exports.llmCompletionPredictionConfigSchema.shape,
    ...exports.llmChatPredictionConfigSchema.shape,
});
//

/***/ }),

/***/ 6653:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmPredictionStatsSchema = exports.llmPredictionStopReasonSchema = void 0;
const zod_1 = __webpack_require__(5995);
exports.llmPredictionStopReasonSchema = zod_1.z.enum([
    "userStopped",
    "modelUnloaded",
    "failed",
    "eosFound",
    "stopStringFound",
    "maxPredictedTokensReached",
    "contextLengthReached",
]);
exports.llmPredictionStatsSchema = zod_1.z.object({
    stopReason: exports.llmPredictionStopReasonSchema,
    tokensPerSecond: zod_1.z.number().optional(),
    numGpuLayers: zod_1.z.number().optional(),
    timeToFirstTokenSec: zod_1.z.number().optional(),
    promptTokensCount: zod_1.z.number().optional(),
    predictedTokensCount: zod_1.z.number().optional(),
    totalTokensCount: zod_1.z.number().optional(),
});
//

/***/ }),

/***/ 5943:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmStructuredPredictionSettingSchema = void 0;
const zod_1 = __webpack_require__(5995);
const JSONSerializable_1 = __webpack_require__(5221);
exports.llmStructuredPredictionSettingSchema = zod_1.z.discriminatedUnion("type", [
    zod_1.z.object({
        type: zod_1.z.literal("none"),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("json"),
        jsonSchema: JSONSerializable_1.jsonSerializableSchema.optional(),
    }),
]);
//

/***/ }),

/***/ 4324:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reasonableKeyStringSchema = void 0;
const zod_1 = __webpack_require__(5995);
/**
 * A string that is reasonable to use as a key. For example, as preset name, model path, or model
 * identifier.
 */
exports.reasonableKeyStringSchema = zod_1.z
    .string()
    .min(1)
    .max(1024)
    .refine(value => value !== "__proto__", {
    message: 'For security reasons, "__proto__" is not allowed',
})
    .refine(value => /\p{C}/u.test(value) === false, {
    message: "Control characters are not allowed",
});
//

/***/ }),

/***/ 8103:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createSystemBackendInterface = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_communication_1 = __webpack_require__(5305);
const lms_shared_types_1 = __webpack_require__(5790);
const zod_1 = __webpack_require__(5995);
function createSystemBackendInterface() {
    return new lms_communication_1.BackendInterface()
        .addRpcEndpoint("echo", {
        parameter: zod_1.z.string(),
        returns: zod_1.z.string(),
    })
        .addRpcEndpoint("listDownloadedModels", {
        parameter: zod_1.z.void(),
        returns: (0, lms_common_1.filteredArray)(lms_shared_types_1.downloadedModelSchema),
    });
}
exports.createSystemBackendInterface = createSystemBackendInterface;
//

/***/ }),

/***/ 390:
/***/ ((module) => {

"use strict";
module.exports = require("@lmstudio/lms-isomorphic");

/***/ }),

/***/ 8033:
/***/ ((module) => {

"use strict";
module.exports = require("chalk");

/***/ }),

/***/ 9771:
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),

/***/ 4402:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"single":{"topLeft":"","topRight":"","bottomRight":"","bottomLeft":"","vertical":"","horizontal":""},"double":{"topLeft":"","topRight":"","bottomRight":"","bottomLeft":"","vertical":"","horizontal":""},"round":{"topLeft":"","topRight":"","bottomRight":"","bottomLeft":"","vertical":"","horizontal":""},"bold":{"topLeft":"","topRight":"","bottomRight":"","bottomLeft":"","vertical":"","horizontal":""},"singleDouble":{"topLeft":"","topRight":"","bottomRight":"","bottomLeft":"","vertical":"","horizontal":""},"doubleSingle":{"topLeft":"","topRight":"","bottomRight":"","bottomLeft":"","vertical":"","horizontal":""},"classic":{"topLeft":"+","topRight":"+","bottomRight":"+","bottomLeft":"+","vertical":"|","horizontal":"-"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LMStudioClient = void 0;
var lms_client_1 = __webpack_require__(7412);
Object.defineProperty(exports, "LMStudioClient", ({ enumerable: true, get: function () { return lms_client_1.LMStudioClient; } }));

})();

module.exports = __webpack_exports__;
/******/ })()
;